<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/fontawesome/css/brands.css" rel="stylesheet">
<link href="/fontawesome/css/solid.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  

  
  <title>高中时期 OI 笔记完全公开（上篇） | 和小loli一起吹萨克斯🎷🎶🎶~</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <meta name="description" content="注意：篇目很长，加载很慢。 偶然间翻到了远古时期 OI 笔记（或者说是日记之类的233），遂发出来以供大家嘲笑纪念。 后篇（或者可能是中篇+后篇）估计要等到寒假拿到旧设备才能观赏了。 没有经过十分严格的审查，欢迎扒黑历史。">
<meta property="og:type" content="article">
<meta property="og:title" content="高中时期 OI 笔记完全公开（上篇）">
<meta property="og:url" content="http://example.com/2023/12/12/old-blog-final-edition/index.html">
<meta property="og:site_name" content="和小loli一起吹萨克斯🎷🎶🎶~">
<meta property="og:description" content="注意：篇目很长，加载很慢。 偶然间翻到了远古时期 OI 笔记（或者说是日记之类的233），遂发出来以供大家嘲笑纪念。 后篇（或者可能是中篇+后篇）估计要等到寒假拿到旧设备才能观赏了。 没有经过十分严格的审查，欢迎扒黑历史。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-12-12T09:48:52.520Z">
<meta property="article:modified_time" content="2023-12-30T08:01:13.261Z">
<meta property="article:tag" content="补档">
<meta name="twitter:card" content="summary">
  
  
    <link rel="shortcut icon" href="/decorations/blogicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="/decorations/banner.jpg" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>和小loli一起吹萨克斯🎷🎶🎶~ </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/blogroll">Blogroll</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="light-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M438.5-829.913v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-829.913Zm0 747.826v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-82.087ZM877.913-438.5h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537t29.476-12.174h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T877.913-438.5Zm-747.826 0h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T82.087-521.5h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T130.087-438.5Zm660.174-290.87-34.239 32q-12.913 12.674-29.565 12.174-16.653-.5-29.327-13.174-12.674-12.673-12.554-28.826.12-16.152 12.794-28.826l33-35q12.913-12.674 30.454-12.674t30.163 12.847q12.709 12.846 12.328 30.826-.38 17.98-13.054 30.653ZM262.63-203.978l-32 34q-12.913 12.674-30.454 12.674t-30.163-12.847q-12.709-12.846-12.328-30.826.38-17.98 13.054-30.653l33.239-31q12.913-12.674 29.565-12.174 16.653.5 29.327 13.174 12.674 12.673 12.554 28.826-.12 16.152-12.794 28.826Zm466.74 33.239-32-33.239q-12.674-12.913-12.174-29.565.5-16.653 13.174-29.327 12.673-12.674 28.826-13.054 16.152-.38 28.826 12.294l35 33q12.674 12.913 12.674 30.454t-12.847 30.163q-12.846 12.709-30.826 12.328-17.98-.38-30.653-13.054ZM203.978-697.37l-34-33q-12.674-12.913-13.174-29.945-.5-17.033 12.174-29.707t31.326-13.293q18.653-.62 31.326 13.054l32 34.239q11.674 12.913 11.174 29.565-.5 16.653-13.174 29.327-12.673 12.674-28.826 12.554-16.152-.12-28.826-12.794ZM480-240q-100 0-170-70t-70-170q0-100 70-170t170-70q100 0 170 70t70 170q0 100-70 170t-170 70Zm-.247-82q65.703 0 111.475-46.272Q637-414.544 637-480.247t-45.525-111.228Q545.95-637 480.247-637t-111.475 45.525Q323-545.95 323-480.247t45.525 111.975Q414.05-322 479.753-322ZM481-481Z"/></svg></span>
      <span class="dark-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M480.239-116.413q-152.63 0-258.228-105.478Q116.413-327.37 116.413-480q0-130.935 77.739-227.435t206.304-125.043q43.022-9.631 63.87 10.869t3.478 62.805q-8.891 22.043-14.315 44.463-5.424 22.42-5.424 46.689 0 91.694 64.326 155.879 64.325 64.186 156.218 64.186 24.369 0 46.978-4.946 22.609-4.945 44.413-14.076 42.826-17.369 62.967 1.142 20.142 18.511 10.511 61.054Q807.174-280 712.63-198.206q-94.543 81.793-232.391 81.793Zm0-95q79.783 0 143.337-40.217 63.554-40.218 95.793-108.283-15.608 4.044-31.097 5.326-15.49 1.283-31.859.805-123.706-4.066-210.777-90.539-87.071-86.473-91.614-212.092-.24-16.369.923-31.978 1.164-15.609 5.446-30.978-67.826 32.478-108.282 96.152Q211.652-559.543 211.652-480q0 111.929 78.329 190.258 78.329 78.329 190.258 78.329ZM466.13-465.891Z"/></svg></span>
    </a>
    
    <div id="nav-menu-btn" class="nav-icon">
      <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M177.37-252.282q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Zm0-186.218q-17.453 0-29.477-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T177.37-521.5h605.26q17.453 0 29.477 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T782.63-438.5H177.37Zm0-186.217q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Z"/></svg>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/blogroll">Blogroll</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/decorations/avatar.png></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">S // W // L </div>
      <div class="dot"></div>
      <div class="subtitle">嘟嘟嘟🎷🎶🎶嘟嘟🎷🎶~ </div>
      <div class="link-list">
        
          <a class="link-btn" href="mailto:saxwithloli<suyouzhao@gmail.com>" title="Email"><i class="fa-solid fa-envelope"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/AsdOkuu" title="Github"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Tags</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%B0%8F%E8%AF%B4/" rel="tag">小说</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%96%87%E5%AD%A6/" rel="tag">文学</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E8%A1%A5%E6%A1%A3/" rel="tag">补档</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E9%98%85%E8%AF%BB/" rel="tag">阅读</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Archives</h3>
      
      
        <a class="archive-link" href="/archives/2024/09 ">
          September 2024 
          <div class="archive-count">4 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/03 ">
          March 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/12 ">
          December 2023 
          <div class="archive-count">2 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Recent Posts</h3>
      <ul>
        
          <a class="recent-link" href="/2024/09/28/central/" title="中心" >
            <div class="recent-link-text">
              中心
            </div>
          </a>
        
          <a class="recent-link" href="/2024/09/25/slave-of-science/" title="科学的奴隶" >
            <div class="recent-link-text">
              科学的奴隶
            </div>
          </a>
        
          <a class="recent-link" href="/2024/09/24/man-of-inexistence/" title="不存在的人" >
            <div class="recent-link-text">
              不存在的人
            </div>
          </a>
        
          <a class="recent-link" href="/2024/09/12/poe1/" title="无意识写作与两首现代散文诗" >
            <div class="recent-link-text">
              无意识写作与两首现代散文诗
            </div>
          </a>
        
          <a class="recent-link" href="/2024/03/01/hesse/" title="黑塞两本书读后感" >
            <div class="recent-link-text">
              黑塞两本书读后感
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-old-blog-final-edition" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        高中时期 OI 笔记完全公开（上篇）
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2023-12-12T09:48:52.520Z" itemprop="datePublished">2023-12-12</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/categories/CS/">CS</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            26k words 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A1%A5%E6%A1%A3/" rel="tag">补档</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <p>注意：篇目很长，加载很慢。</p>
<p>偶然间翻到了远古时期 OI 笔记（或者说是日记之类的233），遂发出来以供<del>大家嘲笑</del>纪念。</p>
<p>后篇（或者可能是中篇+后篇）估计要等到寒假拿到旧设备才能观赏了。</p>
<p>没有经过十分严格的审查，欢迎扒黑历史。</p>
<span id="more"></span>

<h1 id="2021-7"><a href="#2021-7" class="headerlink" title="2021.7"></a>2021.7</h1><h2 id="6-29（把前几天的补一下orz）"><a href="#6-29（把前几天的补一下orz）" class="headerlink" title="6.29（把前几天的补一下orz）"></a>6.29（把前几天的补一下orz）</h2><h4 id="关于博弈问题"><a href="#关于博弈问题" class="headerlink" title="关于博弈问题"></a>关于博弈问题</h4><p>没有模型的问题（树上&#x2F;图上&#x2F;序列上&#x2F;〇〇上），分析分析，多半设计状态先（大概也不能完全叫博弈<strong>论</strong>）</p>
<p>有模型的，，，Bash&#x2F;Fib&#x2F;威佐夫（奇异局势相关）&#x2F;Nim啥有结论就用了转化为其他的题，其他的偏博弈一点的题就SG或N&#x2F;P爆艹<del>（反正大概率草不出来）</del></p>
<h4 id="字典序第k小"><a href="#字典序第k小" class="headerlink" title="字典序第k小"></a>字典序第k小</h4><p>经典$k\rightarrow k&#x2F;k-i$判断的方法，往这方面想，<del>然后就有暴力分了</del>&#x2F;kk</p>
<p>手玩一下，构造几次，找结论罢（<del>本质上还是简化统计前缀的方案数</del>（大悲））</p>
<h4 id="高级数据结构（一）"><a href="#高级数据结构（一）" class="headerlink" title="高级数据结构（一）"></a>高级数据结构（一）</h4><p><code>这个写一条写不完 /kk</code></p>
<p>关于 <em>区间操作查询</em> 啥的玩意（给定一堆操作，询问一段操作后的答案</p>
<p>有两种，询问之间独立的和不独立的</p>
<p>独立的可以用CDQ的思维来看，但大部分情况还是会感觉别扭</p>
<p>最好的还是找到修改之间的联系，正着看反着看咋看都行找到联系套来套去就可以AC（<del>TLE</del>）了</p>
<p>记得倍增大法&#x2F;离线&#x2F;卡常啊kora</p>
<h4 id="关于水题（一）-关于比较乱x的题"><a href="#关于水题（一）-关于比较乱x的题" class="headerlink" title="关于水题（一）&amp;关于比较乱x的题"></a>关于水题（一）&amp;关于比较乱x的题</h4><p><del>读题啊啊啊</del></p>
<p>哭了 水题又挂</p>
<p>总之感觉对于比较杂乱（不管是题面上的、变量上的、逻辑上的）还是要先理清思路罢，</p>
<p>对于这些维度、变量、描述特多的定死顺序有奇效</p>
<p>有的时候先去往某一定死的方向思考（或者说向着自己心中的 <em>灵感</em> 走）反而会出锅</p>
<p><del>读题啊啊啊</del></p>
<h4 id="关于毒瘤题（一）"><a href="#关于毒瘤题（一）" class="headerlink" title="关于毒瘤题（一）"></a>关于毒瘤题（一）</h4><p>心态先稳住吧。。。关于这个我真的不是很有把握&#x2F;kk</p>
<p>而不被题面吓到的 <strong>精神</strong> 想必是紧随其后的罢</p>
<p>不要没手没脚的乱来，推结论先</p>
<h4 id="关于字符串（一）"><a href="#关于字符串（一）" class="headerlink" title="关于字符串（一）"></a>关于字符串（一）</h4><p>现在脑子都麻了。。见到字符串题只会想半天SAM还想不出</p>
<p>这是纯粹字符串底力问题吧？</p>
<p>总之最近多去做做SA，基本的SAM操作都会了，SAM&#x2F;PAM套个不可名状物啥的巨形毒瘤题还是比较少</p>
<h4 id="关于计算几何"><a href="#关于计算几何" class="headerlink" title="关于计算几何"></a>关于计算几何</h4><p>记得有凸壳&#x2F;凸包&#x2F;扫描线&#x2F;闵可夫&#x2F;辛普森，基本上就会拿计算几何打辅助了（？）</p>
<p>退火能别用就别用</p>
<p>还有记得闵可夫怎么写</p>
<h4 id="关于BSGS"><a href="#关于BSGS" class="headerlink" title="关于BSGS"></a>关于BSGS</h4><p>数论题经常都是离正解就差个BSGS。。。</p>
<p>为啥求离散对数的时候还记不得BSGS啊——</p>
<p>总之$a^x&#x3D;b(\mod{c})$记清楚先啊</p>
<p>离散对数啊 离散对数</p>
<p>说到这个分块的块大小记得要灵活点，均一波以防被系数背刺</p>
<h4 id="关于组合题"><a href="#关于组合题" class="headerlink" title="关于组合题"></a>关于组合题</h4><p>经常伪装成奇怪的DP题</p>
<p>有些题还挺智商，往组合想还不好想</p>
<p>总之，<del>警惕新型网络诈骗</del></p>
<h4 id="复杂度的结论"><a href="#复杂度的结论" class="headerlink" title="复杂度的结论"></a>复杂度的结论</h4><p>有些不太记的住。。。</p>
<p>有些树形背包有$O(n^2)$做法</p>
<p>调和$log$</p>
<p>自然数约数个数和$log$</p>
<p>$d(n)$大约在$log$和$\sqrt{n}$之间</p>
<p><strong>主 定 理</strong></p>
<p>无向图中度数种数$O(\sqrt{m})$</p>
<h4 id="高级数据结构（二）"><a href="#高级数据结构（二）" class="headerlink" title="高级数据结构（二）"></a>高级数据结构（二）</h4><p><del>二更</del></p>
<p>别忘了有主席树这种东西（主席树可以单点&#x2F;区间修改，别忘OWO）</p>
<p>有些时候一些看似有关联的东西可以拆开求（如左右端点）</p>
<h2 id="6-30"><a href="#6-30" class="headerlink" title="6.30"></a>6.30</h2><h4 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h4><p>笑死，写了4个小时的缝合怪</p>
<p>最大流费用流倒是不虚（除了缩圈（捂脸）），主要还是上下界流的问题</p>
<p>其次就是网络流模型的运用</p>
<p>最后就是记得有网络流这个东西</p>
<p>没了？<del>没了</del></p>
<p>记得最小割树啊QAQ</p>
<h4 id="图论问题（一）"><a href="#图论问题（一）" class="headerlink" title="图论问题（一）"></a>图论问题（一）</h4><p>有点杂</p>
<p>先讲最短路</p>
<p>标准的最短路肯定没问题，，主要是优化啥的</p>
<p>记得倍增大法&#x2F;二进制分组&#x2F;线段树DS建图&#x2F;对点数、边数的优化</p>
<p>还有就是对于点边数比较小的时候别忘了有Floyd</p>
<p>最后</p>
<h4 id="奇怪的树形DP"><a href="#奇怪的树形DP" class="headerlink" title="奇怪的树形DP"></a>奇怪的树形DP</h4><p>DFS序上的，欧拉序上的</p>
<p>维护线段树的，维护集合的，<del>维护凸壳的</del></p>
<p>记得最优解优化，往往$O(n^2)-&gt;均摊O(nlogn)$</p>
<p>还有DP优化的技巧（容易忘的那种）：单调性（打表），two-pointers</p>
<h4 id="奇怪的数学题"><a href="#奇怪的数学题" class="headerlink" title="奇怪的数学题"></a>奇怪的数学题</h4><p>给个长得很jb高考的函数让你干啥干啥</p>
<p>看着就恶心，你也不会做</p>
<p>但实际上慢慢推一下还是可做的</p>
<p>就是智商方面有待加强（（</p>
<h2 id="7-1"><a href="#7-1" class="headerlink" title="7.1"></a>7.1</h2><h4 id="数论和矩阵"><a href="#数论和矩阵" class="headerlink" title="数论和矩阵"></a>数论和矩阵</h4><p>递推式啥的需要化简或改变形式</p>
<p>技巧方面可以部分预处理平衡复杂度</p>
<p>线代相关。。底力问题，大概就是行列式矩阵的手工化简啥的</p>
<p>和数论函数复合的题手工化简有奇效</p>
<p>化简结果找找规律看能不能直接出或者化成卷积&#x2F;反演的形式</p>
<p>感觉标准形式化不出来可以举例化简</p>
<p>老生常谈.jpg</p>
<h4 id="something-else"><a href="#something-else" class="headerlink" title="something else"></a>something else</h4><p>尽可能保持思维活跃吧</p>
<p>尽量不要觉得不太可做的样子</p>
<p>特别是推出奇怪的式子的时候，模型化能力要跟上</p>
<h4 id="DP（一）"><a href="#DP（一）" class="headerlink" title="DP（一）"></a>DP（一）</h4><p>对于可能会卡在推式子的题，可以尝试运用反函数的思维</p>
<p>记得单调性</p>
<p>能三分甚至可以三分</p>
<h4 id="字符串（二）"><a href="#字符串（二）" class="headerlink" title="字符串（二）"></a>字符串（二）</h4><p>新思路，可以先考虑暴力DP啥的</p>
<p>顺便一提，DP优化不要忘了MeetInMiddle和四边形不等式</p>
<p>又被SAM骗了好气啊（）</p>
<h4 id="关于图论模型"><a href="#关于图论模型" class="headerlink" title="关于图论模型"></a>关于图论模型</h4><p>记得能建图论模型</p>
<p>就行了</p>
<h2 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h2><h4 id="一些看着很计数又很集合的题"><a href="#一些看着很计数又很集合的题" class="headerlink" title="一些看着很计数又很集合的题"></a>一些看着很计数又很集合的题</h4><p>优先考虑DP，先找顺序和不变量，依次列出式子、找到性质</p>
<p>如<br>$$<br>给定 S,C ，你需要计算有多少 (c,s) 满足 1≤c≤C,1≤s≤S 且存在一组边长均为正整数的矩形使得它们的周长之和为 c ，面积之和为 s 。<br>$$<br>这种题，就可以先看出$c&#x2F;s$的最大值为$2$，然后设出$x&#x3D;2s-c$用以标记顺序，且因此有了在集合中加入正方形$x$不变的性质，因此对于固定的$x$来说有$s_{min}$使得$s&gt;&#x3D;s_{min}$存在一合法解。这是构造顺序进行DP的过程。</p>
<p>然后列出关于$x$的DP式子。</p>
<p>然后由于题目有实际意义，可以打表观察法进行__转移点方面的优化__。</p>
<h2 id="7-16"><a href="#7-16" class="headerlink" title="7.16"></a>7.16</h2><h4 id="N2O5-A"><a href="#N2O5-A" class="headerlink" title="N2O5-A"></a>N2O5-A</h4><p>看似很水的一道欺诈题，pollard-rho只有60分&#x2F;kk（因为可能被卡）</p>
<p>实际上有前缀和思想的O(n^2)做法（把log均摊掉）</p>
<p>大概是不断地做G&#x3D;gcd(G, Si)，i递减，S为前缀积</p>
<h4 id="N2O5-B"><a href="#N2O5-B" class="headerlink" title="N2O5-B"></a>N2O5-B</h4><p>定义好点为根当前当前点的最大值为当前点的权值的点，一棵树的权值定义为所有重标号方案的K的好点数次幂和。</p>
<p>求一棵树的权值，要求O(n^2)。</p>
<p>树形DP，做法有点小多</p>
<p>其中一种做法为从叶到根的合并式DP</p>
<p>首先考虑枚举每种好点&#x2F;非好点的方案（针对树点），求出每种方案的总数（针对重标号）</p>
<p>可以发现一种方案对应一种偏序关系，可以在DP的过程中动态维护这种关系。而这样的关系具有特殊的结构特征：每个好点的子树内的点的偏序关系可以在该子树内有关（方法为重构有向树，即小的连向大的），而非好点的子树在除掉该子树内好点的子树后剩下的点构成连通块，且偏序关系未确定且只与祖先好点相关，这样的点定义为散点（在重构树上未定向的点），散点在根向DP时会在遇到好点时贡献，遇到非好点时继承</p>
<p>有了这样的散点的概念，就可以舍弃枚举方案的思想，直接记录散点数，即$DP[i][j]$为$i$点子树里所有情况的贡献之和（其实就是把枚举的方案通过散点这一性质合并了），贡献定义为与树大小相关的乘法，可以$O(n^2)$树形背包。</p>
<p>其次还有容斥的做法，但仍然是树形DP，相当于弱化为有向树确定偏序关系种数的模型（CTS2019D2T2），DP时叶向边直接贡献，根向边拆成__删除__和__反向__两种处理方法，对单个点做容斥，删除为正反向为补，容斥系数为-1，因而可以在DP过程中直接处理，这样做是$O(n)$。扩展到这道题时仍需在重构树上找性质，但可以沿用容斥的基本思想无假。</p>
<h4 id="N2O5-C"><a href="#N2O5-C" class="headerlink" title="N2O5-C"></a>N2O5-C</h4><p>生成函数多项式题，之后补。</p>
<h4 id="N2O6-A"><a href="#N2O6-A" class="headerlink" title="N2O6-A"></a>N2O6-A</h4><p>求$k*k(n&lt;&#x3D;k&lt;&#x3D;m)$，对角线为${a_i(i&lt;&#x3D;n),0(i&gt;n)}$，其余元素为$1$的矩阵的积和式：$\sum_{p_i}\prod_{i} A_{i,p_i}$，$p_i$为排列</p>
<p>实际上很简单</p>
<p>先想$n*n$，枚举取到的对角线数的集合，并使用错排数：</p>
<p>$\sum_S W_{n-|S|}\prod_{i\in S}a_i$</p>
<p>$&#x3D;\sum_{i&#x3D;0}^{n}F_i W_{n-i}$</p>
<p>$F_i$为所有$|S|&#x3D;i$的集合权值的和，所以目前的答案为上述多项式（卷积后）的第$n$项（题目要求的答案为$n$到$m$项）</p>
<p>因为$F_i&#x3D;0(i&gt;n)$，</p>
<p>所以只要求出$F$前$n$项，就可以求出所有的答案</p>
<p>因为$F$与集合大小相关，考虑分治做法，有$F^{l,r}&#x3D;F^{l,mid}<em>F^{mid+1,r}$， $</em>$此处为卷积</p>
<p>$O(nlog^2n)$随便做</p>
<p>TIPS：走火入魔用成容斥就难做了。。</p>
<h4 id="N2O6-B"><a href="#N2O6-B" class="headerlink" title="N2O6-B"></a>N2O6-B</h4><p>给出数组（降序）和递推式子求值</p>
<p>考虑递推式的意义，<del>不</del>可以发现递推式求出的式子为原数组的哈夫曼树（合并石子），$O(nlogn)$裸爆</p>
<p>因为若设$i$为数组元素使用数，$j$为剩余叶子结点数（初始只有根节点），</p>
<p>$(i,j)-&gt;(i+i,j-1)$为把$i$值放到$j$处；</p>
<p>$(i,j)+suf_i-&gt;(i,2j)$为让剩下的叶子节点自己生两个儿子出来（叶子结点翻倍），顺便费用提前计算.</p>
<p><del>怎么想出来的？？</del></p>
<p>话说这种DP挺巧妙的</p>
<h4 id="N2O6-C"><a href="#N2O6-C" class="headerlink" title="N2O6-C"></a>N2O6-C</h4><p>趣事：听讲题的时候一直以为是$10^5$范围，突然发现讲到$O(n^2logn)$没讲了。。</p>
<p>题意为给定$n$个向量和2个点，求$n$个向量中最多$k$个向量之和确定的点与这两个点距离之和的最大值</p>
<p>因为等距点在椭圆上，而我们求的是最外层的点，所以根据与椭圆相切的原理，用线性规划的方法，存在$k$，使得在最大化$z&#x3D;ax+by$，$(x,y)$取A点构成的凸包时取到最优的点</p>
<p>因此暴力做法就是枚举斜率和符号（记得特判$\alpha &#x3D; \pi&#x2F;2$），确定前$k$个点（通过$ax+by$降序排列）</p>
<p>但很明显$ax+by$不重要，重要的是向量之间的偏序关系</p>
<p>我们可以对于每__对__向量求出他们之间的偏序关系变化的阈值，把这$O(n^2)$对阈值排序并依次swap向量的排序，每次在数组的前$k$项使用二分（排除贡献为负的项），时间复杂度为$O(n^2logn)$</p>
<h2 id="7-17"><a href="#7-17" class="headerlink" title="7.17"></a>7.17</h2><h4 id="N2O9-A"><a href="#N2O9-A" class="headerlink" title="N2O9-A"></a>N2O9-A</h4><p>求除了(n,1)以外的上三角稀疏矩阵的行列式q次，每次求都要使k（最多20）个位置变成0，询问之间独立。</p>
<p>第一档：暴力高斯消元</p>
<p>第二档：稀疏矩阵且只对最后一行作用，高斯消元可以O(m)做，最终O(mq)</p>
<p>第三档（k&#x3D;1）：用伴随矩阵$AA^*&#x3D;|A|I$的性质乱杀，O(m+q)</p>
<p>正解：</p>
<p>把矩阵转化成图，问题缩减为求出1-&gt;n的路径权值和（1-&gt;n的路径要求递增，权值为$(-1)^{不在路径内的点数+1}\prod w_{路径内的边}$）</p>
<p>于是乎我们可以把$k$条限制边连接的点提出来构成一个新表，表中$A_{i,j}&#x3D;i\rightarrow j的权值和(i&lt;j,\bold {&lt;i,j&gt;}不是限制边),A_{i,j}&#x3D;0(\bold{&lt;i,j&gt;}为限制边)$，做容斥，系数为-1，因此可以按点顺序遍历做到$O(k^2)$</p>
<p>其中i-&gt;j的权值和可以在询问前做到$O(nm)$的预处理</p>
<p>总复杂度$O(nm+qk^2)$</p>
<h4 id="ABC210E"><a href="#ABC210E" class="headerlink" title="ABC210E"></a>ABC210E</h4><p>智商题，注意奇怪的数论技巧，无从下手就手玩一下</p>
<h4 id="ABC210F"><a href="#ABC210F" class="headerlink" title="ABC210F"></a>ABC210F</h4><p>2-SAT，看得出来就挺经典了</p>
<p>注意到n大约为5e4水平，大概就是要拆成约数&#x2F;质因数</p>
<p>那么最基本的定义就蛮简单：$A_{p,i}&#x3D;拥有质因子p的第i个数被选了,A_{p,i}\rightarrow 非A_{p,j}(j!&#x3D;i)$</p>
<p>同时为每个数建立一个总点，分点向总点连边，总点向分点连边，总点与其对应的数的反命题总点连边</p>
<p>但是这样边数就是$O(n^2log^2n)$，受不住</p>
<p>于是就可以经典地定义前后缀或，$S_{p,i},T_{p,i}$表示前&#x2F;后缀内是否有为正的命题</p>
<p>所以$S_{p,i}\rightarrow S_{p,i+1},S_{p,i}\rightarrow 非T_{p,i+1},非S_{p,i}\rightarrow非S_{p,i-1},非S_{p,i}\rightarrow T_{p,i+1}$</p>
<p>$T_{p,i}$同理</p>
<p>边数降至$O(nlogn)$</p>
<p>记得标准的2-SAT只要任意强联通分量内没有矛盾就是yes</p>
<h2 id="7-18"><a href="#7-18" class="headerlink" title="7.18"></a>7.18</h2><h4 id="N2O9-B"><a href="#N2O9-B" class="headerlink" title="N2O9-B"></a>N2O9-B</h4><p>直接分析</p>
<p>在一个SCC内，周期等于gcd(环长)</p>
<p>证明：从一个点出发进行$gcd$色染色，可以发现染色过程即为该点在图上运动的过程，每个时刻该点占据的点的颜色不断闪烁，周期就是gcd.</p>
<p>在一个图内周期等于lca(SCC的周期)</p>
<p>证明：对于所有$i$有$d_i|D$，即$D$为lca.</p>
<p>思考怎么求SCC内所有环长的gcd</p>
<p>因为我们关注的是gcd而非环长本身，我们可以尝试运用辗转相减&#x2F;除等技巧</p>
<p>我们发现返祖边能形成一个大小可求的环</p>
<p>横叉边能是某一些环的长度加减某个可求的值</p>
<p>于是上述说的所有数据做gcd即为所求</p>
<p>求循环开始处可以倍增矩阵幂解决（<del>倍增和二分相比，那我觉得</del>）</p>
<h4 id="N2O9-C"><a href="#N2O9-C" class="headerlink" title="N2O9-C"></a>N2O9-C</h4><p>首先列出方程，发现系数很范德蒙德行列式，于是考虑用Cramer法则求解</p>
<p>尝试把向量$B$放在向量组${A_n}$的末尾，列出式子$D&#x3D;\prod_{i&#x3D;0,j&lt;i}^{n}(a_i-a_j)$</p>
<p>则$x_i&#x3D;\frac{\frac{D}{\prod_{j!&#x3D;n}(a_n-a_j)}}{-\frac{D}{\prod_{j!&#x3D;i}(a_i-a_j)}}&#x3D;-\frac{\prod_{j!&#x3D;i}(a_i-a_j)}{\prod_{j!&#x3D;n}(a_n-a_j)}$</p>
<p>分母可以直接求，分子设为$D_i&#x3D;\prod_{j!&#x3D;i}(a_i-a_j)$</p>
<p>直接运用快速插值的柿子就行了，但，推导：</p>
<p>有点像拉格朗日插值的柿子，考虑设一个可以消去无关项影响的多项式函数，则可以设$F(x)&#x3D;\sum_{i&#x3D;0}^{n}\prod_{j&#x3D;0,j!&#x3D;i}^{n}(x-a_j)$</p>
<p>则$D_i&#x3D;F(a_i)$</p>
<p>通过<del>观察</del>（<del>智商</del> <del>经验</del> <del>洛必达</del> 快速插值）发现$F(x)&#x3D;\frac{d(\prod_{j&#x3D;0}^{n}(x-a_i))}{dx}$</p>
<p>然后套裸的多点求值就行了（<del>常数变成了一道光</del>）</p>
<h4 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h4><p>复习一下</p>
<h5 id="FFT（扶扶她）"><a href="#FFT（扶扶她）" class="headerlink" title="FFT（扶扶她）"></a>FFT（<del>扶扶她</del>）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FFT</span><span class="params">(C *c, <span class="type">int</span> inv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(R i = <span class="number">0</span>; i &lt; N; i++) <span class="keyword">if</span>(i &lt; r[i]) <span class="built_in">swap</span>(c[i], c[r[i]]);</span><br><span class="line">	<span class="keyword">for</span>(R mid = <span class="number">1</span>; mid &lt; N; mid *= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="function">C <span class="title">tmp</span><span class="params">(cos(pi / mid), inv * sin(pi / mid))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(R i = <span class="number">0</span>; i &lt; N; i += mid * <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="function">C <span class="title">om</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(R j = <span class="number">0</span>; j &lt; mid; j++, om = om * tmp) &#123;</span><br><span class="line">				C x = c[i + j], y = c[i + j + mid] * om;</span><br><span class="line">				c[i + j] = x + y, c[i + j + mid] = x - y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(inv == <span class="number">-1</span>) <span class="keyword">for</span>(R i = <span class="number">0</span>; i &lt; N; i++) c[i].r = c[i].r / N + <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FFT</span><span class="params">(C *c, <span class="type">int</span> inv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(R i = <span class="number">1</span>; i &lt; N; i++) <span class="keyword">if</span>(r[i] &gt; i) <span class="built_in">swap</span>(c[i], c[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(R mid = <span class="number">1</span>; mid &lt; N; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inv == <span class="number">1</span>) <span class="keyword">for</span>(R i = <span class="number">0</span>; i &lt; mid; i++) w[i] = pw[N / mid * i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(R i = <span class="number">0</span>; i &lt; mid; i++) w[i] = iw[N / mid * i];</span><br><span class="line">        <span class="keyword">for</span>(R i = <span class="number">0</span>; i &lt; N; i += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span>(R j = <span class="number">0</span>; j &lt; mid; j++) &#123;</span><br><span class="line">                C x = c[i + j], y = c[i + j + mid] * w[j];</span><br><span class="line">                c[i + j] = x + y; c[i + j + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(inv == <span class="number">-1</span>) <span class="keyword">for</span>(R i = <span class="number">0</span>; i &lt; N; i++) c[i].r = c[i].r / N + <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后者加了单位根的常数优化</p>
<p>单位根为$w_{i}^{j}&#x3D;(j<em>cos(\frac{2\pi}{i}),j</em>sin(\frac{2\pi}{i}))$</p>
<p>${w_{i}^{j}}^{-1}&#x3D;(j<em>cos(\frac{2\pi}{i}),-j</em>sin(\frac{2\pi}{i}))$</p>
<h5 id="NTT（脑瘫瘫）"><a href="#NTT（脑瘫瘫）" class="headerlink" title="NTT（脑瘫瘫）"></a>NTT（<del>脑瘫瘫</del>）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(<span class="type">int</span> *c, <span class="type">int</span> inv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(R i = <span class="number">1</span>; i &lt; N; i++) <span class="keyword">if</span>(r[i] &gt; i) <span class="built_in">swap</span>(c[r[i]], c[i]);</span><br><span class="line">    <span class="keyword">for</span>(R mid = <span class="number">1</span>; mid &lt; N; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> w = <span class="built_in">ksm</span>(g, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(inv == <span class="number">-1</span>) w = <span class="built_in">ksm</span>(w, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(R i = <span class="number">0</span>; i &lt; N; i += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> o = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(R j = <span class="number">0</span>; j &lt; mid; j++, o = <span class="number">1LL</span> * o * w % mod) &#123;</span><br><span class="line">                <span class="type">int</span> x = c[j + i], y = <span class="number">1LL</span> * o * c[j + i + mid] % mod;</span><br><span class="line">                c[i + j] = (x + y) % mod; c[i + j + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(inv == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> w = <span class="built_in">ksm</span>(N, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(R i = <span class="number">0</span>; i &lt; N; i++) c[i] = <span class="number">1LL</span> * w * c[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单位根$w_i^j&#x3D;g^{\frac{M-1}{i}}$</p>
<p>${w_i^j}^{-1}$可以直接快速幂算</p>
<p>同样可以对单位根常数优化</p>
<h5 id="分治FFT"><a href="#分治FFT" class="headerlink" title="分治FFT"></a>分治FFT</h5><p>实际上是CDQ，每层把左边的贡献附加到右边.</p>
<p>可以被多项式求逆替代，挺那啥的.</p>
<p>多项式求逆求解分治FFT：$F(x)&#x3D;F(0)*(1-G(x))^{-1}$</p>
<h5 id="多项式求逆-多项式开根-多项式除法-多项式取模"><a href="#多项式求逆-多项式开根-多项式除法-多项式取模" class="headerlink" title="多项式求逆&amp;多项式开根&amp;多项式除法&amp;多项式取模"></a>多项式求逆&amp;多项式开根&amp;多项式除法&amp;多项式取模</h5><p>阅读<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yoyoball/p/8724115.html">这个博客</a>.</p>
<p>柿子：</p>
<p>多项式求逆：$B(x)&#x3D;G(x)*(2-A(x)*G(x))$</p>
<p>多项式开根：$B(x)&#x3D;\frac{G(x)}{2}+\frac{A(x)}{2G(x)}$</p>
<p>多项式除法：$rev(D(x))\equiv rev(A(x))*rev(B(x))^{-1}(mod\ x^{n-m+1})$</p>
<p>多项式取模：$rev(R(x))&#x3D;rev(A(x))-rev(B(x))*rev(D(x))$</p>
<p>全是$O(nlogn)$</p>
<h5 id="多项式多点求值"><a href="#多项式多点求值" class="headerlink" title="多项式多点求值"></a>多项式多点求值</h5><p>分治+多项式取模，每次取模都可以划分为模数多项式的子问题$O(nlog^2n)$</p>
<p>具体讲讲吧</p>
<p>设你要求的值为$a_i$，生成多项式$B_{l,r}(x)&#x3D;\prod_{i&#x3D;l}^r(x-a_i)$</p>
<p>那么让$F(x)&#x3D;B_{l,mid}(x)D(x)+R_L(x),F(x)&#x3D;B_{mid+1,r}(x)D(x)+R_R(x)$，则$F(a_i)&#x3D;R_L(a_i)$</p>
<p>常数巨大，使用前记得祈祷</p>
<h5 id="快速（龟速）插值"><a href="#快速（龟速）插值" class="headerlink" title="快速（龟速）插值"></a>快速（<del>龟速</del>）插值</h5><p>先对拉格朗日插值的分母经过$N2O9-C$里的推导后应用多点求值</p>
<p>然后分治FFT&#x2F;多项式求逆直接解出来，$O(nlog^2n)$</p>
<p>常数巨大，使用前请务必祈祷 </p>
<h2 id="7-19"><a href="#7-19" class="headerlink" title="7.19"></a>7.19</h2><h4 id="N2O7-A"><a href="#N2O7-A" class="headerlink" title="N2O7-A"></a>N2O7-A</h4><p>贪心做，忽略ci后每只青蛙都没有区别，所以预处理出最多有多少只青蛙能免费渡河，这里可以贪心地往选择右边选择石头</p>
<p>A.有d(&gt;0)只，因为没有用到石头可以加入任意一只免费青蛙的路径里，所以出去免费青蛙都可以以一次代价渡河，排序解决</p>
<p>B.一只都没有，最优情况是让ci最小的青蛙遍历全部石头，其他青蛙一次跳过</p>
<h4 id="N207-B"><a href="#N207-B" class="headerlink" title="N207-B"></a>N207-B</h4><p>首先如果取出3种字母，则答案下界可降低至$\frac{n^2}{9}$</p>
<p>然后尝试搜索长度小于9的所有循环节，尝试上下界剪枝，设当前循环节长度为$k$，取出的序列长度为$m$，某一种数字使用的个数为$j$，则答案为$\frac{m^2}{k}$，而取出该种数字组成的序列答案下界为$\frac{m^2j^2}{k^2}$，相除结果为$\frac{k}{j^2}$，$k$最大值为8，所以在$j\geq 3$时可以减掉，搜索的复杂度因此变得异常地小.</p>
<h4 id="N2O7-C"><a href="#N2O7-C" class="headerlink" title="N2O7-C"></a>N2O7-C</h4><p>观察题目，推导出以下性质：</p>
<ol>
<li>由于B插入A的位置可以随意选择，且A每次删除的模式只与值域有关，故不考虑B中元素时A中元素递增$\Longleftrightarrow$考虑B中元素时A中元素递增</li>
<li>由于A每次删除的模式只与值域有关，故A中元素在值域轴上连续</li>
<li>若选择的值域$E\subset F$，则$F$的答案必不劣于$E$。证明：假设$E+{x}&#x3D;F$，即$E$与$F$只差一个元素，则为清除$x$必须为其安排一个操作。由于奇偶操作有异，则该操作有可能全新，有可能选择一个空操作代替，但不可能减少操作的次数</li>
</ol>
<p>这样就可以每次在A的值域上选择极长连续子段（$w[val[i]]&#x3D;i$）进行模拟，$O(n+m)$</p>
<h4 id="数论复习（上）"><a href="#数论复习（上）" class="headerlink" title="数论复习（上）"></a>数论复习（上）</h4><p>从最基础来</p>
<h5 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="辗转相减法"><a href="#辗转相减法" class="headerlink" title="辗转相减法"></a>辗转相减法</h5><p>主要与数位相关的技巧（如高精度）、线性组合有关</p>
<h5 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h5><p>自反性、对称性、传递性</p>
<p>$a\equiv b(mod\ m),c\equiv d(mod\ m)\longrightarrow a+b\equiv c+d(mod\ m)$</p>
<p>$a\equiv b(mod\ m),c\equiv d(mod\ m)\longrightarrow a<em>b\equiv c</em>d(mod\ m)$</p>
<p>$a\equiv b(mod\ m)\longrightarrow ak\equiv bk(mod\ mk)$</p>
<p>$a\equiv b(mod\ m),d|gcd(a,b,m)\longrightarrow a&#x2F;d\equiv b&#x2F;d(mod\ m&#x2F;d)$</p>
<p>$a\equiv b(mod\ m),d|m\longrightarrow a\equiv b(mod\ d)$</p>
<p>$a\equiv b(mod\ m)\longrightarrow gcd(a,m)&#x3D;gcd(b,m)$</p>
<h5 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h5><p>对于方程$ax+by&#x3D;c$，方程有解 $\Longleftrightarrow gcd(a,b)|c$</p>
<h5 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h5><p>$a*a^{-1}&#x3D;1(mod\ m)$，则称$a^{-1}$为$a$在$mod\ m$下的乘法逆元</p>
<p>$a$有乘法逆元的充要条件为$a\perp m$</p>
<h5 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h5><p>$a\perp m\longrightarrow a^{\phi(m)}\equiv 1(mod\ m)$</p>
<p>$\phi(m)$是欧拉函数</p>
<p>费马小定理是其特殊形式</p>
<h5 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h5><p>求解方程$ax+by&#x3D;gcd(a,b)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b) &#123;x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">gcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$x&#x3D;y’,y&#x3D;x’-\lfloor \frac{a}{b}\rfloor y’$</p>
<p>求出来的解必然有$|x|\leq b,$</p>
<p>通解为$x&#x3D;x_0+k<em>\frac{b}{gcd(a,b)},y&#x3D;y_0-k</em>\frac{a}{gcd(a,b)}$</p>
<h5 id="中国剩余定理（拉格朗日插值）"><a href="#中国剩余定理（拉格朗日插值）" class="headerlink" title="中国剩余定理（拉格朗日插值）"></a>中国剩余定理（<del>拉格朗日插值</del>）</h5><p>求解线性同余方程组$x&#x3D;a_i(mod\ m_i)$，要求$m_i$两两互质</p>
<p>设$M&#x3D;\prod m_i,M_i&#x3D;\prod_{j\neq i}m_j,b_i\equiv M_i(mod\ m_i)$</p>
<p>则$x\equiv \sum_{i&#x3D;1}^{n}a_iM_ib_i(mod\ M)$</p>
<h5 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h5><p>用扩展欧几里得合并方程：</p>
<p>$x&#x3D;x_1+k_1<em>m_1,x&#x3D;x_2+k_2</em>m_2$</p>
<p>$k_1<em>m_1-k_2</em>m_2&#x3D;x_2-x_1$</p>
<p>… …</p>
<p>$x\equiv k_1*m_1+x_1(mod\ lca(m_1,m_2))$</p>
<h5 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h5><p>$a^n\equiv 1(mod\ m)$中，若$n$取最小，则$a\ mod\ m$的阶为$\delta_m(a)&#x3D;n$</p>
<p>$1,a,a^2,…,a^{\delta_m(a)-1}$不同余 </p>
<p>若$a^p\equiv a^q(mod\ m)$，则$p\equiv q(mod\ \delta_m(a))$</p>
<p>若$a\perp m,b\perp m$，则$\delta_m(ab)&#x3D;\delta_m(a)\delta_m(b)\Longleftrightarrow gcd(\delta_m(a),\delta_m(b))&#x3D;1$</p>
<p>$\delta_m(a^k)&#x3D;\frac{\delta_m(a)}{gcd(\delta_m(a),k)}$</p>
<h5 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h5><p>若$gcd(a,m)&#x3D;1,\delta_m(a)&#x3D;\phi(m)$，则$a$为$m$原根</p>
<p>判定：$g^{\phi(m)&#x2F;p}!\equiv 1(mod\ m)$，$p$为$\phi(m)$的因数（不为0或其自身）</p>
<p>原根有$\phi(\phi(m))$个，只有在$m&#x3D;2,4,p^\alpha,2p^\alpha$有原根</p>
<p>最小原根是$O(n^{\frac{1}{4}})$的，所以可以暴力求原根</p>
<h5 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h5><p>求$a^x\equiv b(mod\ m),a\perp m$（离散对数），转化为$a^{A\sqrt{m}}\equiv ba^B(mod\ m)$.</p>
<p>求$x^a\equiv b(mod\ m),m有原根$，设$x&#x3D;g^c$，则转化为$g^{ac}\equiv b(mod\ m)$，即求离散对数.</p>
<p>求$a^x\equiv b(mod\ m)$，当且仅当$gcd(a^{\inf},m)|b$时方程有解</p>
<p>​	让方程变成$\frac{a^k}{D}a^{x-k}\equiv \frac{b}{D}(mod\ \frac{m}{D})$</p>
<p>​	变成$a^{x-k}\equiv \frac{b}{D}(\frac{a^k}{D})^{-1}(mod\ \frac{m}{D})$</p>
<p>​	就可以解了</p>
<h5 id="米勒·拉宾"><a href="#米勒·拉宾" class="headerlink" title="米勒·拉宾"></a>米勒·拉宾</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">mr</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">	ll k = x - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		ll cur = <span class="built_in">qpow</span>(y, k, x);</span><br><span class="line">		<span class="keyword">if</span>(cur != <span class="number">1</span> &amp;&amp; cur != x - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span> || cur == x - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isp</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x == <span class="number">46856248255981LL</span> || x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(x == <span class="number">2</span> || x == <span class="number">3</span> || x == <span class="number">7</span> || x == <span class="number">61</span> || x == <span class="number">24251</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mr</span>(x, <span class="number">2</span>) &amp;&amp; <span class="built_in">mr</span>(x, <span class="number">3</span>) &amp;&amp; <span class="built_in">mr</span>(x, <span class="number">7</span>) &amp;&amp; <span class="built_in">mr</span>(x, <span class="number">61</span>) &amp;&amp; <span class="built_in">mr</span>(x, <span class="number">24251</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>玄学算法，背他就完了</p>
<h5 id="泼辣的·肉"><a href="#泼辣的·肉" class="headerlink" title="泼辣的·肉"></a>泼辣的·肉</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">func</span><span class="params">(ll x, ll c, ll m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">smul</span>(x, x, m) + c) % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pr</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	ll s = <span class="number">0</span>;</span><br><span class="line">	ll t = <span class="number">0</span>;</span><br><span class="line">	ll c = <span class="built_in">rand</span>() % (x - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	ll val = <span class="number">1</span>;</span><br><span class="line">	ll goal = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		ll d;</span><br><span class="line">		<span class="built_in">FOR</span>(step, <span class="number">1</span>, goal) &#123;</span><br><span class="line">			t = <span class="built_in">func</span>(t, c, x);</span><br><span class="line">			val = <span class="built_in">smul</span>(val, <span class="built_in">aBS</span>(t - s), x);</span><br><span class="line">			<span class="keyword">if</span>(step % <span class="number">127</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>((d = <span class="built_in">gcd</span>(val, x)) &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((d = <span class="built_in">gcd</span>(val, x)) &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">		goal &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		s = t;</span><br><span class="line">		val = <span class="number">1</span>;	<span class="comment">//val要重置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h2><h4 id="N2O8-B"><a href="#N2O8-B" class="headerlink" title="N2O8-B"></a>N2O8-B</h4><p>考虑对边分析贡献</p>
<p>发现对于两个相邻空白行来说，其间的边只能经历$up*down$次（因为限制点很稀疏，所以可以思考缩点做法）</p>
<p>于是累计两行贡献，同时把两行合并（相当于边权赋0）</p>
<p>发现把行合并完以后，可以对列合并</p>
<p>最后的图是$O(n^2)$，又由于边权都是1（即还是网格图，点权变了），所以可以$O(n^4)$bfs.</p>
<h4 id="N2O8-C"><a href="#N2O8-C" class="headerlink" title="N2O8-C"></a>N2O8-C</h4><p>你会发现一个点使用B边和R边的数量可以互相表示</p>
<p>于是可设出n-1个未知数</p>
<p>于是可以根据度数列出方程$Ax&#x3D;B$</p>
<p>你会发现$A$是不变的，输入的字符串只改变$B$中的常数，所以可以用矩阵求逆的方法求解线性方程组，$O(n^3+qn^2)$</p>
<p>判无解：显然，所有经过的点必然最终通往输入点$v$，因此所有用过的点最后使用的出边连成的图是$v$的根向树是有解的必要条件（至少最后一次离开的出边一定直接地通往$v$）</p>
<p>假设已经构造出了一个根向树，那么任何不论你在任何一个点，当前开放的是条边，你都可以走到一个最终一定会通往$v$的点，因此根向树是有解的充分条件</p>
<h4 id="数论复习（下）"><a href="#数论复习（下）" class="headerlink" title="数论复习（下）"></a>数论复习（下）</h4><p>数论函数板块</p>
<h5 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h5><p>满足$F(pq)&#x3D;F(p)F(q),p\perp q$</p>
<p>$\epsilon(n)&#x3D;[n&#x3D;1]$</p>
<p>$I(n)&#x3D;1$</p>
<p>$Id(n)&#x3D;n$</p>
<p>$d(n)&#x3D;\sigma_0(n)&#x3D;\sum_{d|n}1$</p>
<p>$\sigma(n)&#x3D;\sigma_1(n)&#x3D;\sum_{d|n}d$</p>
<p>$\phi(n)&#x3D;\sum_{i&lt;n}[i\perp n]$</p>
<p>$\mu(n)&#x3D;{1(n&#x3D;p_1p_2p_3…p_k,2|k),-1(n&#x3D;p_1p_2p_3…p_k,2\perp k),0(otherwise)}$</p>
<p>积性函数与积性函数的狄利克雷卷积是积性函数</p>
<h5 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h5><p>$(f*g)(n)&#x3D;\sum_{d|n}f(d)g(\frac{n}{d})$</p>
<p>$\mu*I&#x3D;\epsilon$</p>
<p>$\phi*I&#x3D;Id$</p>
<p>$\mu*Id&#x3D;\phi$</p>
<h5 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h5><p>$\sum_{d|n}\mu(d)&#x3D;[n&#x3D;1]$，即$\mu*I&#x3D;\epsilon$，基本式</p>
<p>$g(n)&#x3D;\sum_{d|n}f(d)\Longleftrightarrow f(n)&#x3D;\sum_{d|n}\mu(d)g(\frac{n}{d})$</p>
<p>$g(n)&#x3D;\sum_{n|d}f(d)\Longleftrightarrow f(n)&#x3D;\sum_{n|d}\mu(\frac{d}{n})g(d)$</p>
<h5 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h5><p>没啥好讲的，记得$\phi(1)&#x3D;\mu(1)&#x3D;1$以及它们怎么推</p>
<h5 id="数论分块"><a href="#数论分块" class="headerlink" title="数论分块"></a>数论分块</h5><p>别忘就行，记得可以嵌套，记得可以前缀和</p>
<h5 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h5><p>$O(n^{\frac{2}{3}})$求积性函数单点前缀和</p>
<p>$S_f(n)g(1)&#x3D;S_h(n)-\sum_{i&#x3D;2}^nS_f(\lfloor \frac{n}{i}\rfloor)g(i)$</p>
<p>其中$f*g&#x3D;h$</p>
<p>要加以整除分块和合理的记忆化</p>
<h5 id="burnside引理-polya定理"><a href="#burnside引理-polya定理" class="headerlink" title="burnside引理&#x2F;polya定理"></a>burnside引理&#x2F;polya定理</h5><p>$t&#x3D;\frac{1}{|G|}\sum_{i&#x3D;1}^{s}c_1(g_i)$</p>
<p>一个置换群把数字分为等价类的个数为所有置换不动点数的算数平均数</p>
<p>$t&#x3D;\frac{1}{|A|}\sum_{i&#x3D;1}^{s}m^{c(a_i)}$，$c(a_i)$表示置换$a_i$的循环数</p>
<p>一个简单的染色问题中方案数为颜色数的所有置换循环数次方的平均数</p>
<p>burnside是对情况的置换，polya是对染色的置换</p>
<h2 id="7-21"><a href="#7-21" class="headerlink" title="7.21"></a>7.21</h2><h4 id="N2O10-A"><a href="#N2O10-A" class="headerlink" title="N2O10-A"></a>N2O10-A</h4><p>我们尝试优化暴力：枚举诱导子图，如果连通块数为1，答案更新，否则忽略</p>
<p>也就是求：$\sum_{S\subset V}x^{c(S)}(mod\ x^2)$</p>
<p>一般地，可以令$x&#x3D;2$</p>
<p>于是问题转化为对图黑白灰染色，要求黑色只与白&#x2F;灰相连，白色只与黑&#x2F;灰相连</p>
<p>也就是对诱导子图里的连通块黑白染色的结果</p>
<p>直接DP$O(3^{13}n)$</p>
<h4 id="N2O10-B"><a href="#N2O10-B" class="headerlink" title="N2O10-B"></a>N2O10-B</h4><p>鸽，听不懂</p>
<h4 id="N2O10-C"><a href="#N2O10-C" class="headerlink" title="N2O10-C"></a>N2O10-C</h4><p>鸽，还没听</p>
<h2 id="7-22"><a href="#7-22" class="headerlink" title="7.22"></a>7.22</h2><h4 id="数据结构复习"><a href="#数据结构复习" class="headerlink" title="数据结构复习"></a>数据结构复习</h4><p>这个没啥好写的。。。</p>
<h5 id="线段树-树状数组"><a href="#线段树-树状数组" class="headerlink" title="线段树&amp;树状数组"></a>线段树&amp;树状数组</h5><p>没啥</p>
<h5 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h5><p>Splay：写过了，手感很好</p>
<p>FHQtreap：好些，能可持久化，性价比比较高（？）</p>
<p>记得文艺操作啥的东西</p>
<h5 id="树套树"><a href="#树套树" class="headerlink" title="树套树"></a>树套树</h5><p>线段树套平衡树：没啥好讲的，莽就完了</p>
<p>二维线段树：$O(n^2logn)$，拉</p>
<p>树状数组套主席树：相对来说比较好想，都是前缀和嘛</p>
<h5 id="kdt"><a href="#kdt" class="headerlink" title="kdt"></a>kdt</h5><p>很特别的一种数据结构</p>
<p>记得怎么用：维度轮流划分，nth_element，估价函数（到矩形的最大&#x2F;最小距离），根据估价函数暴力回溯搜索</p>
<h5 id="CDQ"><a href="#CDQ" class="headerlink" title="CDQ"></a>CDQ</h5><p>思路是用左边的来贡献右边的</p>
<p>通常思考方法是列出题目中进行贡献的不等式组，依照不等式组的个数套CDQ</p>
<p>一个CDQ的做法是对第一维分治，对第二维排序，对第三维计算贡献</p>
<p>多个CDQ可以把前几维重标号为0&#x2F;1，最后统计贡献的时候只计算(0,0,0…)对(1,1,1…)的贡献</p>
<h5 id="整体二分"><a href="#整体二分" class="headerlink" title="整体二分"></a>整体二分</h5><p>不怎么会&#x2F;kk</p>
<p>答案要有可二分性</p>
<p>修改要相互独立</p>
<p>同时对所有的询问进行二分，在二分区间的同时把询问根据需要分到不同的子区间中</p>
<p>这是最基础的，高级的运用不会了</p>
<h5 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h5><p>很简单</p>
<p>记住：栈内元素是一条链，栈内元素没有连边，出栈的时候才连边，用DFN排序</p>
<h5 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h5><p>轻重链剖分：简单且常用</p>
<p>长链剖分：对付关于深度的DP的宝具。对一个点而言，其能继承其长儿子的DP数组，要动态开数组（其实vector也行）</p>
<h5 id="点分治-点分树"><a href="#点分治-点分树" class="headerlink" title="点分治&#x2F;点分树"></a>点分治&#x2F;点分树</h5><p>记得，能用，就行</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>这个早点复习好</p>
<h5 id="kmp（看-片）"><a href="#kmp（看-片）" class="headerlink" title="kmp（看*片）"></a>kmp（<del>看*片</del>）</h5><p>处理next[i]数组，border</p>
<h5 id="Z算法（扩展kmp）"><a href="#Z算法（扩展kmp）" class="headerlink" title="Z算法（扩展kmp）"></a>Z算法（扩展kmp）</h5><p>不怎么会，爬了</p>
<h5 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h5><p>自动机</p>
<p>原图是一个trie，加入了能够处理失配情况的fail[i]数组，原理是连向极长后缀，可能根据上一个前缀的状态推出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">FOR</span>(i, <span class="number">0</span>, <span class="number">25</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q[++tail] = tr[<span class="number">0</span>][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(tail &gt;= head) &#123;</span><br><span class="line">		<span class="type">int</span> u = q[head++];</span><br><span class="line">		<span class="built_in">FOR</span>(i, <span class="number">0</span>, <span class="number">25</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(tr[u][i]) fail[tr[u][i]] = tr[fail[u]][i], q[++tail] = tr[u][i];</span><br><span class="line">			<span class="keyword">else</span> tr[u][i] = tr[fail[u]][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FOR</span>(i, <span class="number">1</span>, tc) &#123;</span><br><span class="line">		g[fail[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概就是这样，记得第一层特殊处理，在向外更新时处理fail[i]数组</p>
<h5 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">FOR</span>(i, <span class="number">1</span>, n) cnt[rk[i] = s[i]]++;			<span class="comment">//A基数排序</span></span><br><span class="line"><span class="built_in">FOR</span>(i, <span class="number">1</span>, m) cnt[i] += cnt[i - <span class="number">1</span>];			<span class="comment">//A基数排序</span></span><br><span class="line"><span class="built_in">DEC</span>(i, n, <span class="number">1</span>) sa[cnt[rk[i]]--] = i;			<span class="comment">//A基数排序（初始化，以ascii码为关键字）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">1</span>, p; w &lt; n; w *= <span class="number">2</span>, m = p) &#123;</span><br><span class="line">	p = <span class="number">0</span>;									<span class="comment">//B预处理第二维信息</span></span><br><span class="line">	<span class="built_in">FOR</span>(i, n - w + <span class="number">1</span>, n) se[++p] = i;		<span class="comment">//B预处理第二维信息（根据第二维将后缀排序）</span></span><br><span class="line">	<span class="built_in">FOR</span>(i, <span class="number">1</span>, n) &#123;							<span class="comment">//B预处理第二维信息</span></span><br><span class="line">		<span class="keyword">if</span>(sa[i] &gt; w) se[++p] = sa[i] - w;	<span class="comment">//B预处理第二维信息（枚举第二维反过来加入后缀）</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));			<span class="comment">//C基数排序</span></span><br><span class="line">	<span class="built_in">FOR</span>(i, <span class="number">1</span>, n) cnt[fi[i] = rk[se[i]]]++;	<span class="comment">//C基数排序（关键字是第一维，顺便把第二维和第一维对应一下）</span></span><br><span class="line">	<span class="built_in">FOR</span>(i, <span class="number">1</span>, m) cnt[i] += cnt[i - <span class="number">1</span>];		<span class="comment">//C基数排序</span></span><br><span class="line">	<span class="built_in">DEC</span>(i, n, <span class="number">1</span>) sa[cnt[fi[i]]--] = se[i];	<span class="comment">//C基数排序（按第二位顺序安置答案）</span></span><br><span class="line">	<span class="built_in">memcpy</span>(oldrk, rk, <span class="built_in">sizeof</span>(rk));						<span class="comment">//D更新排名数组（作用是在基排中链接两个维度）</span></span><br><span class="line">	p = <span class="number">0</span>;												<span class="comment">//D更新排名数组</span></span><br><span class="line">	<span class="built_in">FOR</span>(i, <span class="number">1</span>, n) &#123;										<span class="comment">//D更新排名数组</span></span><br><span class="line">		rk[sa[i]] = <span class="built_in">cmp</span>(sa[i], sa[i - <span class="number">1</span>], w) ? p : ++p;	<span class="comment">//D更新排名数组（判断相邻的后缀是否相同）</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (p == n) &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sa[rk[i]] = i;		<span class="comment">//E判断break</span></span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>height数组：</p>
<p>$height[i]&#x3D;lca(sa[i],sa[i-1])$，第$i$名和第$i-1$名</p>
<p>有$height[rk[i]]\geq height[rk[i-1]]-1$，第$i$处和第$i-1$处</p>
<p>于是可以$O(n)$预处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k) --k;</span><br><span class="line">    <span class="keyword">while</span> (s[i + k] == s[sa[rk[i] - <span class="number">1</span>] + k]) ++k;</span><br><span class="line">    h[rk[i]] = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>应用：</p>
<ol>
<li>寻找最小循环位移。把字符串复制一遍跑。</li>
<li>在线寻找子串。在后缀数组上二分，比较后缀和模式串的字典序大小。因为模式串的出现在SA里是连续的，所以可以二分出上下界得到匹配数。</li>
<li>首尾取字符最小化字典序。把字符串镜像地复制一遍变成回文串，每次选择的时候比较正向和反向的大小，于是可以贪心地选择。</li>
<li>子串最长公共前缀。运用height数组$lcp(sa[i],sa[j])&#x3D;min{height[i+1…j]}$，变成RMQ力。</li>
<li>比较子串大小。把两个子串对应的后缀求出lcp后比较。</li>
<li>求子串数。分别对每个后缀统计前缀，并减去重复。</li>
<li>子串出现$x$次$\Longleftrightarrow$有连续$k$个后缀以该串为前缀。</li>
<li>不重叠的相同子串$\Longleftrightarrow$在lcp相同的段内&amp;$\Delta$原串下标$\geq$串长</li>
<li>结合数据结构，即按照顺序组织数据，可以以$sa[i],rk[i],height[i]$为维度&#x2F;数据</li>
</ol>
<h5 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> k = ++sc, p = las;</span><br><span class="line">	sam[k].len = sam[p].len + <span class="number">1</span>;</span><br><span class="line">	siz[k] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(; p &amp;&amp; !sam[p].tr[v]; p = sam[p].fa) sam[p].tr[v] = k;<span class="comment">//把上一个位置及其祖先更新</span></span><br><span class="line">	<span class="comment">//printf(&quot;^%d\n&quot;, p);</span></span><br><span class="line">	<span class="keyword">if</span>(!p) sam[k].fa = <span class="number">1</span>;<span class="comment">//没有一个祖先有相同字母的边，link直接连向1</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> q = sam[p].tr[v];</span><br><span class="line">		<span class="keyword">if</span>(sam[q].len == sam[p].len + <span class="number">1</span>) sam[k].fa = q;<span class="comment">//找到的这个祖先加上这个字母就是一个以它为maxlen的等价类，所以该等价类包含k</span></span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//找到的这个祖先加上字母是一个等价类的非maxlen，k和它不成包含关系</span></span><br><span class="line">			<span class="type">int</span> w = ++sc;</span><br><span class="line">			sam[w] = sam[q];</span><br><span class="line">			sam[w].len = sam[p].len + <span class="number">1</span>;<span class="comment">//建一个lca等价类</span></span><br><span class="line">			sam[k].fa = sam[q].fa = w;</span><br><span class="line">			<span class="keyword">for</span>(; p &amp;&amp; sam[p].tr[v] == q; p = sam[p].fa) sam[p].tr[v] = w;<span class="comment">//q不再包含原先的部分endpos转移到了w里，连向q的重定向至w</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	las = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用：</p>
<ol>
<li>模式匹配。</li>
<li>不同子串个数&#x2F;长度和。涉及到不同的子串都可以思考SAM。可以在DAG用路径来DP，也可以在link树上统计等价类的答案。</li>
<li>比较子串字典序的大小。字典序可以通过DAG中路径的权值体现</li>
<li>最小循环位移。基本原理：找子串。把字符串复制一遍寻找最小的|S|串。<ol start="5">
<li>模式匹配求出现次数。涉及到预处理<em>endpos</em>集合的问题。由原串前缀创建的等价类endpos大小初始为1，虚拟lca节点大小初始为0。在link树上做一个子树和就行。</li>
</ol>
</li>
<li>模式匹配求第一个匹配位置。涉及到预处理<em>firstpos</em>（endpos中的最小值）的问题。预处理时字符串前缀点初始值为$len(k)$，新建lca节点时初始值可以为$firstpos[q]$（也可以为0，无所谓），最后做个子树最小值。</li>
<li>最长公共子串。建立S的SAM，对于T依次加点，即在S中找T的每个前缀的最大后缀。每次用前一个状态来匹配当前字符，如果有匹配边则状态++，没有就跳link，即是不断找当前匹配处的前缀。</li>
<li>最长公共子串。建立伪广义后缀自动机，对每个状态状压一个endpos里有哪些原串。找到len最大的满状压的状态。</li>
</ol>
<h2 id="7-23"><a href="#7-23" class="headerlink" title="7.23"></a>7.23</h2><h4 id="图论复习"><a href="#图论复习" class="headerlink" title="图论复习"></a>图论复习</h4><h5 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h5><p>dijkstra，SPFA，floyd</p>
<h5 id="强联通分量-缩点"><a href="#强联通分量-缩点" class="headerlink" title="强联通分量&#x2F;缩点"></a>强联通分量&#x2F;缩点</h5><p>tarjan：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tar</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	low[u] = dfn[u] = ++dc;</span><br><span class="line">	sta[++top] = u;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">VEC</span>(i, g[u]) &#123;</span><br><span class="line">		<span class="type">int</span> v = g[u][i];</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v]) <span class="built_in">tar</span>(v), low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(vis[v]) low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[u] == low[u]) &#123;</span><br><span class="line">		<span class="keyword">while</span>(top) &#123;</span><br><span class="line">			<span class="type">int</span> v = sta[top--];</span><br><span class="line">			col[v] = u;</span><br><span class="line">			vis[v] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(v == u) <span class="keyword">break</span>;</span><br><span class="line">			a[u] += a[v];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强联通分量必有环</p>
<h5 id="割点-点双联通分量"><a href="#割点-点双联通分量" class="headerlink" title="割点&#x2F;点双联通分量"></a>割点&#x2F;点双联通分量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tar</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	low[u] = dfn[u] = ++dc;</span><br><span class="line">	<span class="built_in">VEC</span>(i, g[u]) &#123;</span><br><span class="line">		<span class="type">int</span> v = g[u][i];</span><br><span class="line">		<span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="built_in">tar</span>(v, u);</span><br><span class="line">			low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">			<span class="keyword">if</span>(low[v] &gt;= dfn[u] &amp;&amp; fa) cut[u] = <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt &gt;= <span class="number">2</span> &amp;&amp; !fa) cut[u] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个点可以在多个点双内</p>
<p>仙人掌：每条边最多在一个环上的图</p>
<p>圆方树：对于仙人掌上的一个环建一个方点连向环上的所有圆点</p>
<p>广义圆方树：将普通图按点分划分，每个点分建方点连向点分内的所有圆点</p>
<p>广义圆方树建法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tar</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">	low[u] = dfn[u] = ++dc;</span><br><span class="line">    入栈;</span><br><span class="line">	<span class="built_in">VEC</span>(i, g[u]) &#123;</span><br><span class="line">		<span class="type">int</span> v = g[u][i];</span><br><span class="line">		<span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">			<span class="built_in">tar</span>(v, u);</span><br><span class="line">			low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">			<span class="keyword">if</span>(low[v] &gt;= dfn[u]) &#123;</span><br><span class="line">                出栈直到v;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="桥-边双联通分量"><a href="#桥-边双联通分量" class="headerlink" title="桥&#x2F;边双联通分量"></a>桥&#x2F;边双联通分量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tar</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">	low[u] = dfn[u] = ++dc;</span><br><span class="line">	<span class="built_in">VEC</span>(i, g[u]) &#123;</span><br><span class="line">		<span class="type">int</span> v = g[u][i];</span><br><span class="line">		<span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="built_in">tar</span>(v, u);</span><br><span class="line">			low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">			<span class="keyword">if</span>(low[v] &gt; dfn[u]) [&lt;u,v&gt;是桥];</span><br><span class="line">		&#125;<span class="keyword">else</span> low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和求割点很像</p>
<h5 id="差分约束系统"><a href="#差分约束系统" class="headerlink" title="差分约束系统"></a>差分约束系统</h5><p>求差分最大值：$x-y\leq k$，$y\longrightarrow x$，求最短路</p>
<p>求差分最小值：$x-y\geq k$，$y\longrightarrow x$，求最长路</p>
<h4 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h4><p>处理好条件关系就行了</p>
<p>考虑完所有充分条件后多思考下是否必要</p>
<p>记得tarjan求强联通分量判有解的做法，只要SCC内有解就好</p>
<h4 id="N1O1-A"><a href="#N1O1-A" class="headerlink" title="N1O1-A"></a>N1O1-A</h4><p>转换：极长子段数&#x3D;序列长-相邻两个灯都开着的个数</p>
<p>考虑到题目给出的数据不好维护，思考分块做法：对于总长度&gt;B的颜色，动态维护；对于总长度&lt;&#x3D;B的长度，暴力更新。于是可以动态维护总长&gt;B的颜色相邻的1的个数，每次暴力更新总长&lt;&#x3D;B的颜色的答案，并对前者贡献。</p>
<h4 id="N1O2-B"><a href="#N1O2-B" class="headerlink" title="N1O2-B"></a>N1O2-B</h4><p>设$x_i$为第$i$行处于的时间，则有$x_i-x_j\equiv k(mod\ T)$，则连$i\longrightarrow j:k$，易知周期为最小环的长度。</p>
<p>把矩阵横过来看设$y_i$为第$i$个灯由红转绿的时间，用同样的方法可以求出周期。</p>
<p>在建图后如果只连接相邻权值的边，则可以证明每一个简单环的长度都是周期。</p>
<p>（没怎么看懂，后补）</p>
<h2 id="7-24"><a href="#7-24" class="headerlink" title="7.24"></a>7.24</h2><p>塔诺西的NOI day-x，咕咕咕</p>
<h2 id="7-25"><a href="#7-25" class="headerlink" title="7.25"></a>7.25</h2><h4 id="N102-A"><a href="#N102-A" class="headerlink" title="N102-A"></a>N102-A</h4><p>实际上每个建筑的坚持时间$t_i&#x3D;y_i+z_i$，$z_i$表示i在安全区内的时间。$x-z$图可表示为$(L,0),(M,R-L),(R,0)$</p>
<p>我们设有两个不同的M，$M_1,M_2$，分析它们的左边，发现任选两个$x$处的两个直线的差值$\Delta z$，有$x_1&lt;x_2\Longleftrightarrow \Delta z_1 &lt; \Delta z_2$，所以只要在某个M时有$y_i+z_i&gt;y_j+z_j,x_i&lt;x_j$，则往右的每个时间都有这个式子成立。于是可以把遍历所有$M&#x3D;x_i$，预处理出它们的答案，然后左右一比对就行了（未完）</p>
<h2 id="7-28"><a href="#7-28" class="headerlink" title="7.28"></a>7.28</h2><p>deleted</p>
<h2 id="7-30"><a href="#7-30" class="headerlink" title="7.30"></a>7.30</h2><h4 id="多项式-生成函数"><a href="#多项式-生成函数" class="headerlink" title="多项式&amp;生成函数"></a>多项式&amp;生成函数</h4><h4 id="FFT-NTT"><a href="#FFT-NTT" class="headerlink" title="FFT&amp;NTT"></a>FFT&amp;NTT</h4><p>讲完了</p>
<h4 id="分治FFT-1"><a href="#分治FFT-1" class="headerlink" title="分治FFT"></a>分治FFT</h4><p>①分治做FFT</p>
<p>②分治FFT</p>
<h4 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h4><h5 id="形式幂级数"><a href="#形式幂级数" class="headerlink" title="形式幂级数"></a>形式幂级数</h5><p>只关心多项式系数，不关心x的取值</p>
<p>需要时x取任意值</p>
<p>如$0 &lt; x &lt; 1,1+x+x^2…&#x3D;\frac{1}{1-x}$，且右麦克劳林展开后为左</p>
<p>$f(x)&#x3D;1+x^3+x^6+x^9…&#x3D;\frac{1}{1-x^3}$</p>
<p>$f(x)&#x3D;1+2x+4x^2+8x^3&#x3D;\frac{1-16x^4}{1-2x}$</p>
<p>$f(x)&#x3D;1+2x+3x^2+4x^3…$</p>
<p>$\Longrightarrow f(x)&#x3D;x(f(x)+\frac{1}{1-x})+1$</p>
<p>$\Longrightarrow (1-x)f(x)&#x3D;\frac{1}{1-x}$</p>
<p>$\Longrightarrow f(x)&#x3D;(\frac{1}{1-x})^2&#x3D;(1+x+x^2…)^2$</p>
<h5 id="指数生成函数-EGF"><a href="#指数生成函数-EGF" class="headerlink" title="指数生成函数(EGF)"></a>指数生成函数(EGF)</h5><p>两个EGF卷积能卷出一个组合数，相当于to_permutation</p>
<h5 id="PGF"><a href="#PGF" class="headerlink" title="PGF"></a>PGF</h5><p>$F(x)&#x3D;\sum_{i&#x3D;0}{P(X&#x3D;i)x^i}$</p>
<p>$F(1)&#x3D;\sum_{i&#x3D;0}{P(X&#x3D;i)}&#x3D;1$</p>
<p>$F’(1)&#x3D;\sum_{i&#x3D;0}{P(X&#x3D;i)i}&#x3D;E(X)$</p>
<p>把期望化成了多项式，便于推导和计算</p>
<h5 id="FMT"><a href="#FMT" class="headerlink" title="FMT"></a>FMT</h5><p>求$c_i&#x3D;\sum_{j&amp;k&#x3D;i}a_jb_k$</p>
<p>对$a,b,c$做一个高位后缀和（把$(i)_2$的位看成维，所有超集的和（不能容斥））得到$a’,b’,c’$，脑补一下可得$c’_i&#x3D;a’_ib’_i$（显然）</p>
<p>然后对$c’_i$做个差分就行了</p>
<p>可扩展到k进制</p>
<h5 id="FWT"><a href="#FWT" class="headerlink" title="FWT"></a>FWT</h5><p>或：$FWT(A)&#x3D;(FWT(A_0),FWT(A_0+A_1)),IFWT(A)&#x3D;(IFWT(A_0))$</p>
<h5 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a>子集卷积</h5><p>合并子集的转移：$c_i&#x3D;\sum_{j|k&#x3D;i,j&amp;k&#x3D;0}{a_jb_k}$</p>
<p>占位多项式$\sum{a_ix^{popcnt(i)}}$</p>
<p>把popcnt相同的合并</p>
<h5 id="CF1034E"><a href="#CF1034E" class="headerlink" title="CF1034E"></a>CF1034E</h5><p>发现对$c_ix^j$，$popcnt(i)&lt;&#x3D;j$，那么就可以直接令$x&#x3D;4$，直接做OR卷积，最后每一项除以$4^i$，有贡献的$x^{j-i}$都为$1$.</p>
<h5 id="HDU5823"><a href="#HDU5823" class="headerlink" title="HDU5823"></a>HDU5823</h5><h4 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h4><h5 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h5><p>圆排列</p>
<p>$s(n,k)&#x3D;s(n-1,k-1)+(n-1)s(n-1,k)$</p>
<p>$s(n,k)&#x3D;\sum_{i&#x3D;1}^nC(n-1,i-1)(i-1)!s(n-i,k-1)$</p>
<p>$G_n(x)&#x3D;xG_{n-1}(x)+(n-1)G_{n-1}(x)$，生成函数求一行&#x2F;列</p>
<h5 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h5><p>无区分集合</p>
<p>$S(n,k)&#x3D;S(n-1,k-1)+kS(n-1,k)$</p>
<p>$S(n,k)&#x3D;\sum_{i&#x3D;1}^nC(n-1,i-1)S(n-i,k-1)$</p>
<p>$m^n&#x3D;\sum_{i&#x3D;0}^mC(m,i)i!S(n,i),n\leq m$</p>
<p>二项式反演：$S(m,n)n!&#x3D;\sum_{i&#x3D;0}^n(-1)^{n-i}C(n,i)i^m$</p>
<p>$S(m,n)&#x3D;\sum_{i&#x3D;0}^n\frac{(-1)^i}{i!}\frac{(n-i)^m}{(n-i)!}$</p>
<p>反转公式$\sum_{i&#x3D;m}^nS(n,i)s(i,m)(-1)^{i-m}&#x3D;[m&#x3D;n]$</p>
<p>$\sum_{i&#x3D;m}^ns(n,i)S(i,m)(-1)^{i-m}&#x3D;[m&#x3D;n]$</p>
<p>斯特林反演$f(n)&#x3D;\sum_{k&#x3D;0}^nS(n,k)g(k)\Longleftrightarrow g(n) &#x3D; \sum_{k&#x3D;0}^n(-1)^{n-k}s(n,k)f(k)$</p>
<h5 id="HDU4372（todo）"><a href="#HDU4372（todo）" class="headerlink" title="HDU4372（todo）"></a>HDU4372（todo）</h5><p>考虑最大值在x，则x左边的每个最大值和右边的一堆数形成圆排列</p>
<h5 id="Crash-的文明世界（todo）"><a href="#Crash-的文明世界（todo）" class="headerlink" title="Crash 的文明世界（todo）"></a>Crash 的文明世界（todo）</h5><p>把自然数幂化成第二类斯特林数</p>
<p>直接转化成$\sum_{i&#x3D;0}^{m}S(m,i)i!\sum{C(n,i)}$</p>
<p>相当求右边</p>
<p>组合意义是从任意路径中选取i条边的种数之和</p>
<p>可以在树上DP</p>
<h5 id="CF961G"><a href="#CF961G" class="headerlink" title="CF961G"></a>CF961G</h5><p>对于每个下标列出式子$\sum_iw_i\sum_{j&#x3D;1}^nC(n-1,j-1)jS(n-j,k-1)$</p>
<p>右边的式子化简$\sum_{j&#x3D;1}^{n}C(n-1.j-1)S(n-j,k-1)+\sum_{j&#x3D;1}^n$</p>
<h5 id="2018雅礼-方阵"><a href="#2018雅礼-方阵" class="headerlink" title="2018雅礼 方阵"></a>2018雅礼 方阵</h5><p>只对行进行限制：$g(m)&#x3D;(c^m)^{\underline{n}}$</p>
<p>两种限制同时进行：$f(m)$，有$g(m)&#x3D;\sum_{i&#x3D;0}^{m}S(m,i)f(i)$，（枚举等价的列）</p>
<p>然后反演：$f(m)&#x3D;\sum_{i&#x3D;0}^{m}(-1)^{m-i}s(m,i)g(i)$</p>
<h5 id="ZJOJ2018-历史"><a href="#ZJOJ2018-历史" class="headerlink" title="ZJOJ2018 历史"></a>ZJOJ2018 历史</h5><h4 id="NOI2021E（todo）"><a href="#NOI2021E（todo）" class="headerlink" title="NOI2021E（todo）"></a>NOI2021E（todo）</h4><p>首先明显可以看出是矩阵和平衡树的题</p>
<p>现在的问题是如何处理W和E两种操作和生成序列</p>
<p>首先先让分子分母不翻转，每次按照奇偶性修改分子&#x2F;分母</p>
<p>发现W可以化成加入0 1</p>
<p>E不论最后一个数是否为1，都可以令最后一个数–，然后加入1 1；即加入0 -1 1 1</p>
<p>然后可以构造矩阵塞进平衡树</p>
<p>所以每个点维护4个矩阵：WE反转&#x2F;不反转，WE翻转&#x2F;不翻转</p>
<h4 id="NOI2021D（todo）"><a href="#NOI2021D（todo）" class="headerlink" title="NOI2021D（todo）"></a>NOI2021D（todo）</h4><p>把字符串分成k+1（16）段，鸽笼原理，有可能正确的字符串必有一段和输入匹配</p>
<p>分组，哈希，玄学</p>
<h4 id="NOI2021B（done）"><a href="#NOI2021B（done）" class="headerlink" title="NOI2021B（done）"></a>NOI2021B（done）</h4><p>偶数和奇数的乘法与1和-1的乘法是相似的</p>
<p>每2个交点不改变对答案的贡献，所以从第一层直接连到第n层的交点的奇偶性就是其所有路径的奇偶性</p>
<h4 id="NOI2021C（todo）"><a href="#NOI2021C（todo）" class="headerlink" title="NOI2021C（todo）"></a>NOI2021C（todo）</h4><p>缩点，重构，虚树</p>
<h4 id="牛顿迭代法求逆元"><a href="#牛顿迭代法求逆元" class="headerlink" title="牛顿迭代法求逆元"></a>牛顿迭代法求逆元</h4><p>用于求$mod\ p^k$意义下的逆元</p>
<p>类似于多项式求逆&#x2F;开根</p>
<p>$xA\equiv 1(mod\ p^k)$</p>
<p>$xB\equiv 1(mod\ p^{2k})$</p>
<p>$(B-A)^2\equiv 0(mod\ p^{2k})$</p>
<p>$B^2-2AB+A^2\equiv 0(mod\ p^{2k})$</p>
<p>$B\equiv A(2-Ax)(mod\ p^{2k})$</p>
<h4 id="数论-例题1"><a href="#数论-例题1" class="headerlink" title="[数论]例题1"></a>[数论]例题1</h4><p>$C(n,i)&#x3D;\frac{n^{\underline{i}}}{i!}$，预处理逆元直接递推</p>
<h4 id="数论-例题2"><a href="#数论-例题2" class="headerlink" title="[数论]例题2"></a>[数论]例题2</h4><p>只要区间里有质数，就是正解</p>
<p>小区间直接搜</p>
<h4 id="欧拉定理推广"><a href="#欧拉定理推广" class="headerlink" title="欧拉定理推广"></a>欧拉定理推广</h4><p>$a^b\equiv a^{min(b\ mod\ \phi(m) + \phi(m), b)}(mod\ m)$</p>
<h4 id="数论-BZOJ3884"><a href="#数论-BZOJ3884" class="headerlink" title="[数论]BZOJ3884"></a>[数论]BZOJ3884</h4><p>求$2^{2^{2^{…}}}\equiv x(mod\ p)$</p>
<p>相当于求$左\equiv x’(mod\ \phi(p))$</p>
<h2 id="7-31"><a href="#7-31" class="headerlink" title="7.31"></a>7.31</h2><h4 id="群论"><a href="#群论" class="headerlink" title="群论"></a>群论</h4><p>陪集分解 轨道稳定集定理</p>
<h4 id="CF1508D（done）"><a href="#CF1508D（done）" class="headerlink" title="CF1508D（done）"></a>CF1508D（done）</h4><p>对于单独的一个环，可以找到一个根节点做一个菊花</p>
<p>对于多个环，可以尝试交换点，合并成一个大环</p>
<p>按照极角排序，每次交换只交换极角相邻的点，可以保证有解</p>
<h4 id="CF1442D（done）"><a href="#CF1442D（done）" class="headerlink" title="CF1442D（done）"></a>CF1442D（done）</h4><p>最多只有一个数组没有选满</p>
<p>考虑分治，递归选择没选满的数组，则每次往下走都把另一边的数组背包合并，最后找到的那个位置就枚举前缀</p>
<h4 id="AGC046D（done）"><a href="#AGC046D（done）" class="headerlink" title="AGC046D（done）"></a>AGC046D（done）</h4><p>设$dp[i][j][k]$为删到了$i$处，自由$0$有$j$个，自由$1$有$k$个的可行性</p>
<p>这个可以直接推</p>
<p>但是对于不同的状态，其0,1总数可能相同，直接统计有可能造成重复累计</p>
<p>于是考虑按从后往前的顺序只统计最先出现的0,1状态（因为相对而言后缀的长度越小，对最后的结果的要求越松，相当于从后到前的答案集合是包含关系）</p>
<p>继续设$num[i][j][k]$表示总共$i$个$0$，$j$个$1$，从后往前匹配到$k$的所有字串数，求出这个数组后对每个(i,j)从后往前枚举，只计算最后的答案即可</p>
<h4 id="CF-GYM101630G（done）"><a href="#CF-GYM101630G（done）" class="headerlink" title="CF-GYM101630G（done）"></a>CF-GYM101630G（done）</h4><p>二分答案便乘求方案数，考虑枚举x求满足条件的y的数量，可以主席树做</p>
<h4 id="CF1326F2（untodo）"><a href="#CF1326F2（untodo）" class="headerlink" title="CF1326F2（untodo）"></a>CF1326F2（untodo）</h4><p>只考虑两人之间认识的限制，求出来的方案数是超集之和</p>
<p>相当于对n-1的每种划分数找链，求方案数</p>
<p>（然后不会了）</p>
<h4 id="CF-GYM102538G（doing）"><a href="#CF-GYM102538G（doing）" class="headerlink" title="CF-GYM102538G（doing）"></a>CF-GYM102538G（doing）</h4><p>做一个生成树，正常的点分树只记录重心到黑点的距离，改成记录重心的和所有有跨子树边的其中一个节点到黑点的距离即可</p>
<p>一个分治块内的关键点到每个点的距可以暴力bfs	</p>
<h4 id="Quasi-template（todo）"><a href="#Quasi-template（todo）" class="headerlink" title="Quasi-template（todo）"></a><a target="_blank" rel="noopener" href="https://szkopul.edu.pl/problemset/problem/gpqiCQ0dD0Vehy10VEsTlUsi/site/?key=statement">Quasi-template</a>（todo）</h4><p>建出SAM，可以预处理出每个等价类能够覆盖的[1,L]（也有可能没法覆盖到最前面，就忽略），之后就是原串后缀的前缀覆盖，对反串做kmp，border长度即为可以覆盖的最大长度</p>
<h4 id="Isomorphic-Matrices（todo）"><a href="#Isomorphic-Matrices（todo）" class="headerlink" title="Isomorphic Matrices（todo）"></a>Isomorphic Matrices（todo）</h4><p>套burnside.不动点个数为$k^{连通块数}$，对于一个行上环长为$x$，列上环长为$y$的一个矩阵，连通块数为$gcd(x,y)$，所以对于一个划分，总答案为$\prod_i\prod_j k^{gcd(x_i,y_j)}$，于是对于小维枚举划分数，对大维exp求$\prod_{j}k^{gcd(x,y_i)}$</p>
<h4 id="CF-GYM102538D（todo）"><a href="#CF-GYM102538D（todo）" class="headerlink" title="CF-GYM102538D（todo）"></a>CF-GYM102538D（todo）</h4><p>因为这是一个排列，所以可以发现一个杨表对(A,B)（A表示值，B表示下标）和排列形成了双射，且相同形态的A与B的集合相同</p>
<p>于是划分数一下，然后钩子公式算出这种形态的杨表的方案数，其对应的排列数就是它的平方</p>
<p>钩子公式：$\frac{n!}{\prod_{i&#x3D;1}^n{l_i+1}}$，$l_i$为钩子长度</p>
<h4 id="CF-GYM102391E（todo）"><a href="#CF-GYM102391E（todo）" class="headerlink" title="CF-GYM102391E（todo）"></a>CF-GYM102391E（todo）</h4><p>二分答案后对仙人掌的dfs树树形DP，环的信息在深度最小的点处理。维护$dp[i]$表示在$dp[i]$中的最远距离$\leq mid$的情况下，以$i$为根，到$i$子树中的最远的点的距离。至于环，可以把返祖边以外的边拉在一条直线上暴力删边，变成处理前后缀信息.</p>
<h4 id="TOPCODER12158（todo）"><a href="#TOPCODER12158（todo）" class="headerlink" title="TOPCODER12158（todo）"></a>TOPCODER12158（todo）</h4><p>（待补）</p>
<h4 id="LOJ3192（todo）"><a href="#LOJ3192（todo）" class="headerlink" title="LOJ3192（todo）"></a>LOJ3192（todo）</h4><p>首先，被包含的桌子是可以删掉的，于是桌子在l单调的时候r单调。</p>
<p>其次，只考虑一个班，那么相邻高度的人挨着坐是最优的（考虑为一个班安排桌子）。</p>
<p>那么就可以为每个位置寻找最合适的桌子，使得这个位置对m组人费用最小</p>
<p>有决策单调性，可以二分</p>
<h4 id="CODECHEF-TREEWALK（todo）"><a href="#CODECHEF-TREEWALK（todo）" class="headerlink" title="CODECHEF-TREEWALK（todo）"></a>CODECHEF-TREEWALK（todo）</h4><p>我们要求的答案矩阵即为$A^n$，由Cayley-Hamilton定理，设A的特征多项式为f(x)，则f(A)&#x3D;0</p>
<p>所以$x^n<del>mod</del>f(x)$在$x&#x3D;A$时为$A^n$</p>
<p>所以求出$g(x)&#x3D;x^n<del>mod</del>f(x)$即可，这一步倍增可做</p>
<p>为此需要求出$f(x)&#x3D;|xI-A|$，相当于在某个矩阵中选若干环</p>
<p>由于原图是树，故选$Len&gt;2$的环是没有贡献的只需要考虑自环（单点）和2环（两个相邻点）</p>
<p>可以树形DP做</p>
<h4 id="HDU5457（todo）"><a href="#HDU5457（todo）" class="headerlink" title="HDU5457（todo）"></a>HDU5457（todo）</h4><p>假设只考虑P操作，那么建出正向trie，问题即为ban掉树上的边，求root到leaf都不联通的最小代价</p>
<p>那么在P,S都有的情况下，同时建出正向和反向trie树，将相同的叶子结点连在一起，即求root_1到root_2的最小代价，最小割模型</p>
<h4 id="LOJ2462（todo）"><a href="#LOJ2462（todo）" class="headerlink" title="LOJ2462（todo）"></a>LOJ2462（todo）</h4><p>首先可以以每个点为根DP求出包含根的合法连通块最大权值和，以这个思路可以求出每个点&#x2F;边能在多少个集合里充当重要点&#x2F;连接重要点的边</p>
<p>由于任何情况下重要点均形成连通块，故每种情况的权值（即为1）能表示为1&#x3D;点数-边数</p>
<p>换维（原本是按集合枚举点），为每个点&#x2F;边算出其贡献，只需要$C(n,k)$，$n$为第一段求出来的值（即是所有能取的集合里取子集）</p>
<p>类似exlucas的计算$C(n,k)<del>mod</del>5^{23}$：</p>
<h1 id="2021-8"><a href="#2021-8" class="headerlink" title="2021.8"></a>2021.8</h1><h2 id="8-2"><a href="#8-2" class="headerlink" title="8.2"></a>8.2</h2><h4 id="网络流-1"><a href="#网络流-1" class="headerlink" title="网络流"></a>网络流</h4><h5 id="Shoot-The-Bullet（todo）"><a href="#Shoot-The-Bullet（todo）" class="headerlink" title="Shoot The Bullet（todo）"></a>Shoot The Bullet（todo）</h5><p>裸题，直接感性建图</p>
<h5 id="支线剧情（todo）"><a href="#支线剧情（todo）" class="headerlink" title="支线剧情（todo）"></a>支线剧情（todo）</h5><p>尝试对原图做网络流，每条边容量为$[1,inf)$，费用为$w_i$，为每个点加一条通往源点，容量为$[0,inf)$，费用为$0$的边，跑无源汇上下界最小费用可行流</p>
<h5 id="Snuke-The-Phantom-Thief（todo）"><a href="#Snuke-The-Phantom-Thief（todo）" class="headerlink" title="Snuke The Phantom Thief（todo）"></a>Snuke The Phantom Thief（todo）</h5><p>发现是前缀，多跑几次板子</p>
<h5 id="面国修路"><a href="#面国修路" class="headerlink" title="面国修路"></a>面国修路</h5><p>即最小化选择的边数，最大费用最小流</p>
<h5 id="机场（todo）"><a href="#机场（todo）" class="headerlink" title="机场（todo）"></a>机场（todo）</h5><p>做过&#x2F;cy</p>
<h5 id="GDOI2019-棋盘（todo）"><a href="#GDOI2019-棋盘（todo）" class="headerlink" title="GDOI2019 棋盘（todo）"></a>GDOI2019 棋盘（todo）</h5><p>待补</p>
<h5 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h5><p>线性规划</p>
<h4 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h4><h5 id="围绕着我们的圆环（todo）"><a href="#围绕着我们的圆环（todo）" class="headerlink" title="围绕着我们的圆环（todo）"></a>围绕着我们的圆环（todo）</h5><p>$$<br>\begin{aligned}<br>&amp;C&#x3D;AB\<br>列向量表示<del>&amp;A&#x3D;(v_1,v_2,\ldots,v_q)\<br>列向量表示</del>&amp;C&#x3D;(u_1,u_2,\ldots,u_s)\<br>&amp;u_k&#x3D;\sum{v_iB_{i,k}}\<br>方案数为~&amp;2^{(q-r(A))s}\<br>r维线性空间，取一组基，&amp;A每一列都是基生成，可以当成r维列向量</p>
<p>\end{aligned}<br>$$</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/daklqw/p/11508682.html">https://www.cnblogs.com/daklqw/p/11508682.html</a></p>
<h5 id="？？？"><a href="#？？？" class="headerlink" title="？？？"></a>？？？</h5><p>不是很听得懂</p>
<h4 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h4><h5 id="Determinant"><a href="#Determinant" class="headerlink" title="Determinant"></a>Determinant</h5><p>对一个边双缩点，爆算（考虑到缩点出来的边永远不会被选）</p>
<h5 id="Determination"><a href="#Determination" class="headerlink" title="Determination"></a>Determination</h5><p>没听懂</p>
<h4 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h4><h5 id="跳蚤猜密码（todo）"><a href="#跳蚤猜密码（todo）" class="headerlink" title="跳蚤猜密码（todo）"></a>跳蚤猜密码（todo）</h5><h4 id="Cauchy-Binet-公式"><a href="#Cauchy-Binet-公式" class="headerlink" title="Cauchy-Binet 公式"></a>Cauchy-Binet 公式</h4><h5 id="Yet-Another-Linear-Algebra-Problem"><a href="#Yet-Another-Linear-Algebra-Problem" class="headerlink" title="Yet Another Linear Algebra Problem"></a>Yet Another Linear Algebra Problem</h5><p>发现$det(A*A^{T})$直接套就是枚举的过程</p>
<h4 id="LGV-引理"><a href="#LGV-引理" class="headerlink" title="LGV 引理"></a>LGV 引理</h4><h5 id="Intersection-is-not-allowed"><a href="#Intersection-is-not-allowed" class="headerlink" title="Intersection is not allowed!"></a>Intersection is not allowed!</h5><p>模板题</p>
<h5 id="网格（todo）"><a href="#网格（todo）" class="headerlink" title="网格（todo）"></a>网格（todo）</h5><p>终于听懂了&#x2F;ll</p>
<p>考虑只有一条路径时的方案数，可以容斥DP：</p>
<p>$f[i][j]$ 表示在选 $i$ 的情况下任意选择必达节点集合（保证 $i$ 最后到达），总共经过了 $j$ 个节点的方案数</p>
<p>可以 $O(n)$ 转移，复杂度 $O(n^3)$</p>
<p>我们发现如果要两条路径不交，那必然是 $(0,1)\rightarrow(n-1,m),(1,0)\rightarrow(n,m-1)$</p>
<p>于是套LGV就可以了</p>
<h4 id="Matrix-Tree-定理"><a href="#Matrix-Tree-定理" class="headerlink" title="Matrix-Tree 定理"></a>Matrix-Tree 定理</h4><h5 id="作业题（todo）"><a href="#作业题（todo）" class="headerlink" title="作业题（todo）"></a>作业题（todo）</h5><p>有gcd求和，可以考虑反演（待补）<br>$$<br>\begin{aligned}</p>
<p>\end{aligned}<br>$$</p>
<h4 id="欧拉回路计数（BEST定理）"><a href="#欧拉回路计数（BEST定理）" class="headerlink" title="欧拉回路计数（BEST定理）"></a>欧拉回路计数（BEST定理）</h4><p>$T(G)\prod_{i&#x3D;1}^{n}{(out_i-1)!}$ ， $T(G)$ 表示以任意节点为根的内向树数量</p>
<h5 id="奥林匹克环城马拉松（todo）"><a href="#奥林匹克环城马拉松（todo）" class="headerlink" title="奥林匹克环城马拉松（todo）"></a>奥林匹克环城马拉松（todo）</h5><p><a target="_blank" rel="noopener" href="https://vfleaking.blog.uoj.ac/blog/1991">https://vfleaking.blog.uoj.ac/blog/1991</a></p>
<p>树边的定向必可确定</p>
<p>环上边只要为一条边定向就可以定向所有边</p>
<p>然后就直接套了</p>
<h4 id="特征值、特征向量、特征多项式"><a href="#特征值、特征向量、特征多项式" class="headerlink" title="特征值、特征向量、特征多项式"></a>特征值、特征向量、特征多项式</h4><p>若对实数 $\lambda$ ，有 $\lambda u&#x3D;Au,u\neq \bold{0}$ ，则 $\lambda$ 称为 $A$ 的一个特征值，非零向量 $u$ 为 $A$ 的一个特征向量，所有 $u$ 形成的线性空间称为特征子空间记为 $V_\lambda$</p>
<p>$\lambda$ 为 $A$ 的特征值当且仅当 $|\lambda I-A|&#x3D;0$，故设 $f(\lambda)&#x3D;|\lambda I-A|$ 为 $A$ 的特征多项式，为 $n$ 次多项式，$f_A(\lambda)$ 中的重数称为代数重数， $\lambda$ 的特征子空间的维数称为几何重数，几何 $\leq$ 代数</p>
<p>$\sum \lambda&#x3D;\sum A_{i,i}$ ， $\prod \lambda&#x3D;|A|$</p>
<h4 id="矩阵相似、对角化"><a href="#矩阵相似、对角化" class="headerlink" title="矩阵相似、对角化"></a>矩阵相似、对角化</h4><p>若 $B&#x3D;PAP^{-1}$ ，则 $A$ 与 $B$ 相似</p>
<p>相似不改变特征多项式、迹、行列式、特征值</p>
<p>若 $A$ 可对角化，则存在对角阵 $B$ 使得 $A&#x3D;PBP^{-1}$，故 $B$ 的对角线即为 $A$ 的特征值， $P$ 的各列对应特征向量</p>
<h2 id="8-3"><a href="#8-3" class="headerlink" title="8.3"></a>8.3</h2><h4 id="转置算法"><a href="#转置算法" class="headerlink" title="转置算法"></a>转置算法</h4><h5 id="无reverseFFT"><a href="#无reverseFFT" class="headerlink" title="无reverseFFT"></a>无reverseFFT</h5><p>转置后一模一样，则可以对DFT转置，对IDFT不转置，则reverse抵消</p>
<h5 id="转置算法多点求值"><a href="#转置算法多点求值" class="headerlink" title="转置算法多点求值"></a>转置算法多点求值</h5><p>学会了，待补</p>
<h5 id="CF-GYM102978D"><a href="#CF-GYM102978D" class="headerlink" title="CF-GYM102978D"></a>CF-GYM102978D</h5><p>学会了，待补</p>
<h5 id="TREE-PRIME"><a href="#TREE-PRIME" class="headerlink" title="TREE&amp;PRIME"></a>TREE&amp;PRIME</h5><p>设 $a_k$ 为金币数为 $k$ 个的贡献（0&#x2F;1），$F_{i,j}$ 表示到第 $i$ 个点金币数为 $j$ 的概率，$b$ 为答案序列，则转置算法为<br>$$<br>a_k&#x3D;\sum_{i&#x3D;1}^n b_iF_{k},\F_i&#x3D;\prod_{j\in Path(1,i)}{(p_jx+1-p_j)}<br>$$<br>直接求</p>
<p>（简单的思路是改变向量所乘的维度，感性地看）</p>
<h4 id="组合计数1（todo）"><a href="#组合计数1（todo）" class="headerlink" title="组合计数1（todo）"></a>组合计数1（todo）</h4><p>引理(Prufer)：</p>
<p>有k个连通块，大小为ai，总结点数为n，加边形成生成树的方案数为<br>$$<br>n^{k-1}\prod a_i\<br>$$<br>又有<br>$$<br>g*2^g&#x3D;(x+1)^g2^g&#x3D;<a href="2x+2">x^1</a>^g<br>$$<br>于是设 $t&#x3D;2x+2$ ，求<br>$$<br>\begin{aligned}<br>\sum_{T_2}[x^1]t^{T_1\cap T_2}&amp;&#x3D;[x^1]\sum_{T_2}(t-1+1)^{T_1\cap T_2}\<br>&amp;&#x3D;[x^1]\sum_{T_2}\sum_{E\sube T_2 &amp;E\sube T_1}(t-1)^{|E|}\<br>&amp;&#x3D;[x^1]\sum_{E\sube T_1}(t-1)^{|E|}|E\sube T_2|\<br>&amp;&#x3D;[x^1]\sum_{E\sube T_1}(t-1)^{|E|}n^{k_E-2}\prod_{i&#x3D;1}^{k_E}{a_E}<em>i\<br>&amp;&#x3D;\sum</em>{E\sube T_1}([x^1]\sum_{i&#x3D;0}^{|E|}\binom{|E|}{i}(2x)^i)n^{k_E-2}\prod_{i&#x3D;1}^{k_E}{a_E}<em>i\<br>&amp;&#x3D;2\sum</em>{E\sube T_1}|E|n^{k_E-2}\prod_{i&#x3D;1}^{k_E}{a_E}<em>i\<br>\end{aligned}<br>$$<br>可以记dp数组 $f</em>{i,0&#x2F;1}$ 表示第 $i$ 个点子树内考虑&#x2F;不考虑第 $i$ 号点所在连通块的答案（我猜的，写的时候再说）</p>
<p>无了&#x2F;kk</p>
<h4 id="组合计数2（untodo）"><a href="#组合计数2（untodo）" class="headerlink" title="组合计数2（untodo）"></a>组合计数2（untodo）</h4><p>康拓展开能展开成各位之和，$|b_i&gt;b_j\and i&lt;j|*(n-i)!$</p>
<p>枚举每个a_i求出其位置j的概率乘期望</p>
<p>对每一轮每一个数分析贡献：<br>$$<br>\begin{aligned}<br>&amp;\sum_{k&#x3D;0}^{\infty}\sum_{l&#x3D;0}^{i-2}\sum_{r&#x3D;0}^{n-i}\binom{i-2}{l}\binom{n-i}{r}(n-l-r-1)!(1-q^{k+1})^l(1-q^k)^rq^{(k+1)(i-1-l)}q^{k(n-i-r)}pq^k\<br>&amp;令q^k&#x3D;t,i!&#x3D;u^i\<br>原式&amp;&#x3D;\sum_{l&#x3D;0}^{i-2}\sum_{r&#x3D;0}^{n-i}\binom{i-2}{l}\binom{n-i}{r}u^{n-l-r-1}(1-qt)^l(1-t)^r(qt)^{i-1-l}t^{n-i-r}pt\<br>&amp;&#x3D;pqut^2(1+qt(u-1))^{i-2}(1+t(u-1))^{n-i}\<br>&amp;设v^{\dot{}}&#x3D;u(u-1)^{\dot{}},x^\dot{}&#x3D;t^2(tv)^\dot{}\<br>原式&amp;&#x3D;pq(1+qx)^{i-2}(1+x)^{n-i}<br>\end{aligned}<br>$$<br>即求 $x$ 的系数</p>
<p>然后转置&#x2F;fad&#x2F;fad&#x2F;fad</p>
<p>然后不会了&#x2F;kk&#x2F;kk</p>
<h4 id="SAM-1"><a href="#SAM-1" class="headerlink" title="SAM"></a>SAM</h4><h5 id="你的名字（todo）"><a href="#你的名字（todo）" class="headerlink" title="你的名字（todo）"></a>你的名字（todo）</h5><p>裸的parent树上统计答案</p>
<p>线段树合并和树剖都能做</p>
<h5 id="LUOGU4482（todo）"><a href="#LUOGU4482（todo）" class="headerlink" title="LUOGU4482（todo）"></a>LUOGU4482（todo）</h5><p>$len(lcs(y,r))\geq y-l+1$</p>
<p>则变成 $l + len(x) &gt; y$</p>
<p>考虑离线，树链剖分对每个重链开个堆记录其轻子树中的查询。在每次 $r$ 加入时把 $(l+len(x),id)$ $O(log^2n)$ 加入</p>
<p>查询时让$y$ 跳重链，每次把重链里比 $y$ 大的全部取出来（已经被取过直接pop），也是 $O(log^2n)$</p>
<h4 id="runs"><a href="#runs" class="headerlink" title="runs"></a>runs</h4><p>$r&#x3D;(i,j,p)$ 周期为 $p$ ，区间为 $[i,j]$ 的极长循环串，且最少循环 $2$ 次，且 $[i,i+p-1]$ 非周期（既没有比 $p$ 小的周期）</p>
<p>长度为 $n$ 的字符串的runs最多有 $n-1$ 个</p>
<p>对于非周期的串 $s$ ，有一种循环移位是lyndon串</p>
<p>对于一个runs，存在长度为 $p$ 的子串为lyndon串</p>
<p>$l_t(i)&#x3D;max{j|s[i,j]在&lt;_t的意义下为lyndon串}$</p>
<p>对于 $s_{j+1}&lt;<em>0s</em>{j-p+1}$ ，$l_0(a)&#x3D;b$</p>
<p>$l_0(i)&#x3D;i<del>or</del>l_1(i)&#x3D;i$</p>
<p>求法：duval算法</p>
<h4 id="CF446D（todo）"><a href="#CF446D（todo）" class="headerlink" title="CF446D（todo）"></a>CF446D（todo）</h4><p>首先想办法处理出所有限制点不经过别的限制点时互相之间的可达概率，之后就可以矩阵快速幂</p>
<p>考虑dp，首先对所有限制点求出每个非限制点不经过限制点到它的概率，写成方程组的形式</p>
<p>发现每次系数矩阵完全不变，只有常数矩阵改变，于是可以扩展未知数向量和常数向量至矩阵</p>
<p>然后对于限制点到限制点就可以直接推了</p>
<h2 id="8-4"><a href="#8-4" class="headerlink" title="8.4"></a>8.4</h2><h4 id="ZRA1-A"><a href="#ZRA1-A" class="headerlink" title="ZRA1-A"></a>ZRA1-A</h4><p>对每个点按切比雪夫距离从内到外枚举答案，总共是 $O(n^2)$ 的</p>
<h4 id="ZRA1-B"><a href="#ZRA1-B" class="headerlink" title="ZRA1-B"></a>ZRA1-B</h4><p>对于一个矩形，可以选择两个边缘；考虑把一个图分成很多矩形，则易知只需要选择一半的轮廓，找找规律可知答案为 $C&#x2F;2+1$ （C为周长）</p>
<p>考虑每次找一个外围的点，可以发现如果删掉这个点周长不变，则这个点不会贡献；如果删掉这个点周长-&#x3D;2，则会贡献</p>
<p>如此贪心即为正解</p>
<h4 id="ZRA1-C"><a href="#ZRA1-C" class="headerlink" title="ZRA1-C"></a>ZRA1-C</h4><p>慢慢写</p>
<h4 id="概率期望"><a href="#概率期望" class="headerlink" title="概率期望"></a>概率期望</h4><ol>
<li>$\sum_{i&#x3D;1}^{n}\frac{n}{n-i+1}$​</li>
<li>$\frac{1}{i}$</li>
<li>$\sum_{i\neq j}{\frac{2}{ij}}+\sum{\frac{1}{i}}$</li>
<li>$\frac{1}{2}$</li>
<li>$\frac{1}{m!}$ &#x2F; $\frac{(n-m+1)!}{n!}$</li>
<li>$1+\sum_{i&#x3D;2}^{n}\frac{a_i}{a_1+a_i}$</li>
<li>$E_i(X^2)&#x3D;p(E_{i-1}(X^2)+2E_{i-1}(X)+1)+(1-p)E_{i-1}(X)$​</li>
<li>$\frac{2}{(i-j)(i-j+1)}$</li>
<li>$$</li>
<li>建出DAG，题目即为入度为0的点选完的期望次数</li>
</ol>
<h2 id="8-6"><a href="#8-6" class="headerlink" title="8.6"></a>8.6</h2><h4 id="CF446D"><a href="#CF446D" class="headerlink" title="CF446D"></a>CF446D</h4><p>建新图只有关键点，枚举所有关键点跑出所有非关键走到他概率，列出方程组发现所有的系数矩阵都是一样的，可以矩阵求逆</p>
<h4 id="ZRA3-A"><a href="#ZRA3-A" class="headerlink" title="ZRA3-A"></a>ZRA3-A</h4><p>柯西&#x2F;单调性凸性&#x2F;whk数学&#x2F;乱搞</p>
<h4 id="ZRA3-B"><a href="#ZRA3-B" class="headerlink" title="ZRA3-B"></a>ZRA3-B</h4><p>支配树，一个点必经的所有点都在其到根的路径上</p>
<p>BFS出一个DAG  在DAG上一边建树一边缩点，和s缩到一个部分的点答案为0 否则答案为1（不连通特判）</p>
<h4 id="ZRA3-C"><a href="#ZRA3-C" class="headerlink" title="ZRA3-C"></a>ZRA3-C</h4><p>1.$\sum len_i\leq 2<em>10^5\Longrightarrow count(len_i)&#x3D;O(\sqrt{2</em>10^5})$</p>
<p>所以在AC自动机每次往上跳，关键点只有 $O(\sqrt{n})$</p>
<p>AC自动机每个关键点记录第一个关键点祖先即可</p>
<p>$O(kn\sqrt{n})$</p>
<p>2.考虑在SAM上跑所有的t串，可以串长分块，对于 $&gt;\sqrt{n}$ 的串暴力DFS；对于 $\leq\sqrt{n}$ 的串可以在parent树上暴力维护数组</p>
<h2 id="8-7"><a href="#8-7" class="headerlink" title="8.7"></a>8.7</h2><h4 id="ZRA4-A"><a href="#ZRA4-A" class="headerlink" title="ZRA4-A"></a>ZRA4-A</h4><p>线段树合并求出以每个点为中间点的方案数&#x2F;主席树维护DFN上的数据</p>
<h4 id="ZRA4-B"><a href="#ZRA4-B" class="headerlink" title="ZRA4-B"></a>ZRA4-B</h4><p>可以设计DP： $dp[i][j][k][l][m]$ 表示总点数，度数为0,1,2,3的点的个数的方案数，可以 $O(Kn^5)$ DP</p>
<p>但应该发现其不保证所有点连成连通块</p>
<p>设 $G(n)&#x3D;\sum_{i,j,k,l} dp[n][i][j][k][l]$ ，表示不保证联通的方案数， $F(n)$ 表示保证联通的方案数</p>
<p>则有 $F(n)&#x3D;G(n)-\sum_{i&#x3D;1}^{n-1}\binom{n-1}{i-1}F(i)G(n-i)$ ，即是 $F(n)&#x3D;\ln G(n)$​ ， $O(n^2)$ 解决</p>
<h4 id="ZRA4-C"><a href="#ZRA4-C" class="headerlink" title="ZRA4-C"></a>ZRA4-C</h4><p>数据随机，联想到生日悖论，取 $\sqrt{p}$ 个点时得到正解的概率极大</p>
<p>于是可以每次取不同的随机点值， $O(n\sqrt{p})$ 解决</p>
<p>发现每次选点求一次点值效率太低，发现DFT即是求单位根的点值的过程</p>
<p>于是可以选这 $O(n)$ 个单位根的点值作为点值，正确率极高</p>
<h2 id="8-8"><a href="#8-8" class="headerlink" title="8.8"></a>8.8</h2><h4 id="ZRA5-A"><a href="#ZRA5-A" class="headerlink" title="ZRA5-A"></a>ZRA5-A</h4><p>使用之前的结论，推一下规律（周长&#x2F;田字格）</p>
<h4 id="ZRA5-B"><a href="#ZRA5-B" class="headerlink" title="ZRA5-B"></a>ZRA5-B</h4><p>首先，可以DP： $f_{i,j}\rightarrow f_{i,j-c_{k,i}},f_{i,j}\rightarrow f_{i-1,j*a_{i-1}}$，其中$c_{k,i}$ 为 $k$ 物品在使用 $i(i\geq d_k)$ 种货币时向上取整的价值</p>
<p>之所以能想到这种转移，是因为数据过大无法全部转化为某一种货币，可能需要面值从大到小分层转移</p>
<p>这样做会发现 $\sum_{i}c_{k,i}$ 是 $O(c_k)$ 的（每次减少一半），于是每一层暴力分治NTT即为答案</p>
<h4 id="ZRA5-C"><a href="#ZRA5-C" class="headerlink" title="ZRA5-C"></a>ZRA5-C</h4><p>原理：点集划分</p>
<p>首先明显地确定了 $a,b,c$ 的任意一个以后就可以在 $2n$ 次内找到答案</p>
<p>那么我们需要先随意选择一个点： $x$ ， $n$ 次查询出其连边</p>
<ol>
<li>$d(x)&#x3D;n-2$，则 $c&#x3D;x$ ，则可以在之后 $n$ 次确定 $a,b$ ；</li>
<li>$d(x)\leq 2$，则 $x$ 有可能是 $a,b$ ，则在 $2n$ 次内找到 $x$ 的邻点的连边，然后对这至多 $2$ 个点判断 $a,b,c$ ，则必有其中一个，之后至多 $2n$ 次找到答案；</li>
<li>$3\leq d(x)\leq n-3$ ，则该点一定和 $c$ 相邻，一定不和 $a,b$ 相邻，与 $a,b$ 相邻的点只会有 $c$ ，然后<strong>划分出相邻与不相邻的两种点集</strong>，每次在这两个点集中最多 $n$ 次选点查边，若有边，则删掉不相邻集的该点，否则删掉相邻集的该点，最后两个点集一定只有不相邻集非空，则最后使用的点就是 $a$ ，然后 $2n$​ 次过.</li>
</ol>
<h4 id="ABC213G"><a href="#ABC213G" class="headerlink" title="ABC213G"></a>ABC213G</h4><p>裸的状压DP</p>
<p>设计状态为 $f(S)$​ 表示 $S$​ 形成连通块的方案数，则一次容斥，经典地枚举与 $x$​ 相连的连通块个数，再设 $g(S)$​ 表示随意选择 $S$​ 中边的方案数，则有转移 $f(S)&#x3D;g(S)-\sum_{x\in T}f(T)g(S-T)$​ ，于是就可以愉快地AC了</p>
<h4 id="ABC213H"><a href="#ABC213H" class="headerlink" title="ABC213H"></a>ABC213H</h4><p>首先明显是多项式，根据题意可以直接对该图的多项式矩阵做快速幂，但明显 $O(n^3Tlog^2T)$ 的复杂度不能满足我们的要求</p>
<p>考虑优化，题目中最明显的一个性质即是起点和终点都是1，所以每次更新只枚举最后走的边，即设计DP<br>$$<br>f_{i,j}&#x3D;\sum_{k\in E,i\in k}\sum_{l&#x3D;0}^j f_{to_k,l}p_{k,j-l}<br>$$<br>明显是一个卷积的形式，列为多项式的形式<br>$$<br>F_i(x)&#x3D;\sum_{k\in E,i\in k}F_{to_k}(x)*P_k(x)<br>$$<br>这个式子为在线DP，不能直接FFT</p>
<p>但是我们注意到每个 $[x^0]F_i$ 都确定，每个 $P_k$ 都已完全给出</p>
<p>则可以分治FFT，具体来讲，就是最外层套CDQ，每层分治跑一边图上的全部卷积</p>
<p>妙啊</p>
<p>$O(mTlog^2T)$</p>
<h2 id="8-9"><a href="#8-9" class="headerlink" title="8.9"></a>8.9</h2><h4 id="ZRA6-B"><a href="#ZRA6-B" class="headerlink" title="ZRA6-B"></a>ZRA6-B</h4><p>假设该图是无向图，则在在该图上找到一个环作为其哈密顿回路，则环外的边都可以抽象为偏序关系</p>
<p>我们尝试从排列映射到无向图的集合，方法是将排列首尾相连变成环，根据排列每个点对 $(i,j)$ 的偏序关系判断边 $(i-1,j)$ 能否存在于原图中</p>
<p>ban掉的偏序关系即为逆序对。所以答案就变成求n排列的q的逆序对数次方和了</p>
<p>柿子：<br>$$<br>\begin{aligned}<br>&amp;p^n\sum_{i&#x3D;2}^{n-1}(1-p)^{i-2}v_i\sum_{j&#x3D;i+1}^{n}(1-p)^{n-j}v_j\sum_{p_{n-3}}(1-p)^{\sigma(p)}\<br>\end{aligned}<br>$$</p>
<h4 id="ZRA6-C"><a href="#ZRA6-C" class="headerlink" title="ZRA6-C"></a>ZRA6-C</h4><p>枚举 $j$ ，对每个 $i$ 找到一个 $k$ 的取值区间 $[f_i,g_i)$ 则答案为 $\sum max(g_i-f_i,0)$ </p>
<h4 id="CF1557D"><a href="#CF1557D" class="headerlink" title="CF1557D"></a>CF1557D</h4><p>DP式子为 $f_i&#x3D;\max{f_j+1}$ ，直接维护横向的线段树，每次区间修改即可</p>
<h4 id="CF1557E"><a href="#CF1557E" class="headerlink" title="CF1557E"></a>CF1557E</h4><p>考虑把国王逼到第 $8$ 行的角落。先把皇后放在 $(1,1)$​ ，则皇后覆盖的方格将把网格分为2个块</p>
<p>每次纵向移动皇后，若在这个过程中国王向下走，则皇后也向下走；若走到底国王都没向下走，则国王位于下半块，此时就向下走反方向遍历纵向就好了</p>
<h2 id="8-10"><a href="#8-10" class="headerlink" title="8.10"></a>8.10</h2><h4 id="ZRA7-B"><a href="#ZRA7-B" class="headerlink" title="ZRA7-B"></a>ZRA7-B</h4><p>拍到dfn上相当于求 $\sum_{i&#x3D;l}^{r+1}[a_i&gt;a_{i+1}]&#x3D;0$ 的点数，每次修改都是在将某点往上跳更新每个节点，可以直接树剖</p>
<h2 id="8-11"><a href="#8-11" class="headerlink" title="8.11"></a>8.11</h2><h4 id="ZRA8-B"><a href="#ZRA8-B" class="headerlink" title="ZRA8-B"></a>ZRA8-B</h4><p>考虑在PAM上DP，算出以每个状态 $u$ 的答案，乘上size</p>
<p>每个 $s_{i}$ 可以由 $s_{i-1}$ 将l&#x2F;r边界的其中一个移动，然后取前缀&#x2F;后缀得到</p>
<p>于是设计DP：$f_{i,0}$ 表示 $s_1&#x3D;i$ 的方案数， $f_{i,1}$ 表示 $[l_i,r_i]$ 中所有回文串的方案数总和， $f_{i,2}$ 表示$ [l_i,r_i]$ 中至少卡着一个边界的回文串的方案数总和， $f_{i,3}$ 表示 $[l_i,r_i)$ 的所有回文串的方案数总和（和 $(l_i,r_i])$​ 等价）</p>
<p>$p_i$ 表示PT上的father， $b_i$ 表示parent树上的father<br>$$<br>f_{i,0}&#x3D;f_{p_i,1}+1\<br>f_{i,1}&#x3D;f_{i,2}+f_{j,1}\<br>f_{i,2}&#x3D;f_{i,0}+2f_{b_i,3}+2f_{b_i,0}\<br>f_{i,3}&#x3D;f_{b_i,3}+f_{b_i,0}<br>$$</p>
<h2 id="8-12"><a href="#8-12" class="headerlink" title="8.12"></a>8.12</h2><h4 id="ZRA9-B"><a href="#ZRA9-B" class="headerlink" title="ZRA9-B"></a>ZRA9-B</h4><p>假如两个点的最短路到达了同一个点，则该点以后两点的最短路将会重合。</p>
<p>那么我们尝试分析求最短路的过程，则若对于某个点1比2先到则将其设为 $l$ （若对2来说该点在最短路上，则对1来说经过该点的路一定比其短；否则对1来说这条路选为 $l$ 更优）；若对于某个点1比2后到则将其设为 $r$ 。</p>
<p>同时到需要分类讨论：若需要判断WIN，则要尽量使2经过的路径尽量长，故使之为 $r$；若需要判断DRAW，需要阻止2从另一条路径到达，故使之为 $l$</p>
<h2 id="8-13"><a href="#8-13" class="headerlink" title="8.13"></a>8.13</h2><h4 id="ZRA10-B"><a href="#ZRA10-B" class="headerlink" title="ZRA10-B"></a>ZRA10-B</h4><p>首先有 $x^2\Longleftrightarrow \log_2\log_2x+1$​ </p>
<h2 id="8-14"><a href="#8-14" class="headerlink" title="8.14"></a>8.14</h2><h4 id="FJOI2014-病毒防护带"><a href="#FJOI2014-病毒防护带" class="headerlink" title="[FJOI2014]病毒防护带"></a>[FJOI2014]病毒防护带</h4><p>写出点到直线的距离公式，发现这个式子看着就很凸</p>
<p>直接三分套三分</p>
<p>证明用偏导</p>
<h4 id="FJOI2014-树的重心"><a href="#FJOI2014-树的重心" class="headerlink" title="[FJOI2014]树的重心"></a>[FJOI2014]树的重心</h4><p>假设只有一个重心，其将整棵树分成许多子树，一个连通块必然是在子树里选​，则必有 $siz_v\leq \frac{1}{2}\sum{siz_u}$</p>
<p>然后可以发现有两个重心的情况，一定是在把两重心之间的边看做一个点的前提下，该点两个子树大小相等，同样符合上式</p>
<p>先dp出每个子树选择每种点数的方案数（ $O(n^2)$ ），然后再做一遍背包，正反两遍合并背包（ $O(n^3)$ ），之后 $O(n)$ 枚举子树，每次 $O(n^2)$ 合并背包</p>
<p>这样会算重，但算重只有可能是2个子树大小相等，只需要 $O(n^3)$ 枚举子树对和大小</p>
<h1 id="2021-9"><a href="#2021-9" class="headerlink" title="2021.9"></a>2021.9</h1><h2 id="8-24"><a href="#8-24" class="headerlink" title="8.24"></a>8.24</h2><h3 id="AGC001F"><a href="#AGC001F" class="headerlink" title="AGC001F"></a>AGC001F</h3><p>首先考虑对于逆排列即为满足 $|i-j|&#x3D;1$，$|p_i-p_j|\geq k$ 的数对可以交换，于是可以认为 $|p_i-p_j|&lt;k$ 的数对的位置关系不变，于是建图，对于 $|p_i-p_j|&lt;k,i&lt;j$ ，连 $&lt;i,j&gt;$ 有向边，最终能建出DAG</p>
<p>对于这一DAG不能直接贪心选取最小，因为这是逆排列，有字典拓扑定理：</p>
<blockquote>
<p>  对于任意一个DAG的一个拓扑序 $p$，$p$ 最大是 $p^{-1}$ 最大的充要条件；最小则不满足。</p>
</blockquote>
<p>脑补得证</p>
<p>所以在反图上求最大拓扑序即可，然而不能直接建图</p>
<p>考虑对于一个点，其入度为 $(p_i-k,p_i+k)$ 内序号大于它的数个数</p>
<p>这个东西可以通过权值线段树&#x2F;set初始化</p>
<p>然后每次找 $[1,n]$ 区间内 $(in_i,i)$ 第一关键字最小的前提下，第二关键字最大的元素，可以线段树维护，每次修改相当于对 $(p_i-k,p_i+k)$ 内的全部元素度数 $-1$，$p_i$ 处度数赋值为 $\infty$​ </p>
<h2 id="8-25"><a href="#8-25" class="headerlink" title="8.25"></a>8.25</h2><h3 id="AGC002F"><a href="#AGC002F" class="headerlink" title="AGC002F"></a>AGC002F</h3><p>可以转化为放置 $n$ 个白球和 $n(k-1)$ 个彩球，保证对于每个前缀位置有白球个数 &gt; 彩球种类数</p>
<p>发现这些限制只与白球和每种彩球的第一个有关，于是考虑dp，设 $f_{i,j}$ 表示放了 $i$ 个白球和 $j$ 个第一个彩球</p>
<p>转移分为两部分：</p>
<ol>
<li>放置白球，直接贡献 $f_{i,j}+&#x3D;f_{i-1,j}$</li>
<li>放置彩球，枚举彩球的种类，并且选择序列之后的某些位置放置这种彩球 $f_{i,j}+&#x3D;f_{i,j-1}(n-j+1)\binom{nk-(j-1)(k-1)-i-1}{k-2}$</li>
</ol>
<p>就做完了</p>
<h3 id="AGC003E"><a href="#AGC003E" class="headerlink" title="AGC003E"></a>AGC003E</h3><p>好他妈弔。。</p>
<p>发现对于 $n_i\geq n_{i+1}$，$i$ 是无用的，所以只用记录后缀最小值就行了</p>
<p>从后往前考虑，划分为子问题，有 $ans_i&#x3D;\lfloor\frac{n_i}{n_{i-1}}\rfloor ans_{i-1}+ans_{i-1}[1,n_i%n_{i-1}]$​</p>
<p>对于加号前是直接递归，对于加号后最大化一个 $pos$ 使得 $n_{pos}\leq n_i%n_{i-1}$，则又可以划分为 $X&#x3D;\lfloor\frac{n_i%n_{i-1}}{n_{pos}}\rfloor ans_{pos}+ans_{pos}[1,(n_i%n_{i-1})%n_{pos}]$​（若不保证pos最大，则不能保证 $n_x$​ 之后的元素满足他的性质）；若找不到则可以直接在原序列上进行贡献（右端点落在原序列上）</p>
<p>右边的子问题递归 $O(\log n)$ 次（取模的性质），每次总共有 $n$ 次递归，所以总的复杂度为 $O(n\log^2n)$</p>
<p>直接递归复杂度是错的，从小到大求不好求，所以从大到小枚举，每次为之后所有的 $ans$ 累计贡献次数</p>
<p>做完了</p>
<h3 id="AGC004F"><a href="#AGC004F" class="headerlink" title="AGC004F"></a>AGC004F</h3><p>大力分类讨论</p>
<p>I. $n$ 为奇数</p>
<p>​	黑点数每次变化2，无解</p>
<p>II. $n$ 为偶数</p>
<p> A. $m&#x3D;n-1$</p>
<p>​	树是二分图，所以可以黑白染色，新树的规则变为不同颜色的点可以交换颜色，目的是让黑白点交换</p>
<p>​	于是染色后如果黑白点数不一样则无解</p>
<p>​	否则对每条边分析贡献，为 $|a-b|$ ，分别为子树内的黑点数&#x2F;白点数</p>
<p>B. $m&#x3D;n$</p>
<p>​	考虑拆边</p>
<p>​	1.$\ $环长为偶数</p>
<p>​		拆出来的边仍然是颜色不同的点交换颜色</p>
<p>​		于是会发现其连接的两个点到他们的lca的两条链分别加x和-x，就约等于一个 $\sum |w_i-x|$ 直接上中位数</p>
<p>​	2.$\ $环长为奇数</p>
<p>​		拆出来的边只能把同种颜色的点转换颜色</p>
<p>​		于是只要要求黑白点数差值为偶数即可</p>
<p>​		平衡黑白点之后这条边就没用了，转换成了树</p>
<h3 id="AGC005D"><a href="#AGC005D" class="headerlink" title="AGC005D"></a>AGC005D</h3><p>先容斥，$f(x)$ 表示钦定 $x$ 个位置满足 $|p_i-i|&#x3D;k$ 的方案数</p>
<h3 id="ARC114C"><a href="#ARC114C" class="headerlink" title="ARC114C"></a>ARC114C</h3><p>拆下贡献呗</p>
<p>相当于一个连通图中(i,j)要联通需要其之间的数全部大于等于他们，最终就是统计连通图的个数</p>
<p>对每一对(i,j)计算他们联通的方案数，用全部的方案数减他们就是+1的贡献次数，可以直接算</p>
<h2 id="8-30"><a href="#8-30" class="headerlink" title="8.30"></a>8.30</h2><h3 id="ZRNOIPA1-C"><a href="#ZRNOIPA1-C" class="headerlink" title="ZRNOIPA1-C"></a>ZRNOIPA1-C</h3><p>其询问为序列的种类数，而序列的每个位置只和SCC个数有关（而非SCC的大小、形态之类），因此考虑进行构造。对于一张图，让其加边，有三种可能，一种是全加在SCC中，序列下一项不变；一种是加在SCC与SCC之间但不形成新的SCC，序列下一项不变；一种是加在SCC与SCC之间，序列下一项要减一个数。</p>
<p>要求序列的形态最多，即是要求前两种情况能加的边数最多，且第三种情况能够缩进去的SCC最多。</p>
<p>对于前者，考虑总共有 $m$ 个SCC，那么 $m-1$ 个1，$1$ 个 $n-m+1$ 能提供最多的空位</p>
<p>对于后者，在同样的图的情况下，优先把SCC连成链，一条边能缩的SCC最多</p>
<p>所以考虑DP $f(i,j,k)$ 表示已经加了 $i$ 条边，在最大的SCC内有 $j$ 条有意义的边（即DP过程中加进去的边，明显是 $O(n)$ 的；不用记录具体有多少边的原因是只用找最优化的图而非记录图的个数），最大的SCC大小为 $k$：（那么SCC连成的链长为 $\min(i-j+1,n-k+1)$）<br>$$<br>f(i,j,k)\rightarrow f(i+1,j,k):i+1\leq \frac{k(k+1)}{2}+\frac{(n-k)(n-k+1)}{2}\<br>f(i,j,k)\rightarrow f(i+1,j+x+1,k+x):x\in[1,\min(i-j+1,n-k+1)]}\<br>%f(i,j,k)&#x3D;f(i-1,j-x-1,k-x),x\in[1,max(k,)]<br>$$<br>这个式子的状态是 $O(n^4)$ 的，转移可以前缀和优化</p>
<h2 id="8-31"><a href="#8-31" class="headerlink" title="8.31"></a>8.31</h2><h3 id="ZRNOIPA1-D"><a href="#ZRNOIPA1-D" class="headerlink" title="ZRNOIPA1-D"></a>ZRNOIPA1-D</h3><p>首先，事实：对于一个异或和为0的集合，其任意子集的异或和相等</p>
<p>那么就很明显了：只有当所有数异或和为0，才会平局</p>
<p>然后从高到低位考虑，显然只需要考虑最高位有奇数个1的位</p>
<p>接下来相对比较难判断，考虑能否分类讨论</p>
<p>当n为偶数时A和B取的数字个数相等，于是手玩发现A和B分别能取到奇数和偶数位置的数（这两个集合一定分别是0&#x2F;1），而这是A决定的，所以A必胜</p>
<p>当n为奇数时，比较容易转化为偶数，继续分类讨论</p>
<p>当两边都是0：一定转化为偶数的情况，先手必败</p>
<p>所以如果两边有1，则先手一定会选1，转化为了偶数个位置偶数个1的情况</p>
<p>考虑一种避免必败的策略</p>
<p>如果B选了0：A必须选0，否则进入必败</p>
<p>如果B选了1：A必须选1，否则进入必败</p>
<p>那么把两边相等的东西删掉以后一定只有2个极长连续段（手玩）</p>
<p>做完了（好长（大嘘））</p>
<h3 id="口胡记录-ARC115"><a href="#口胡记录-ARC115" class="headerlink" title="[口胡记录]ARC115"></a>[口胡记录]ARC115</h3><p>迫真口胡 前20min rush：</p>
<p>A(1min)：M只有20，异或之后数1的个数</p>
<p>B(4min)：对C的每一行做差分，看数组们是否相等，然后无脑构造</p>
<p>C(6min)：相当于求mex，显然不能暴力求。但是发现对于一个数可以直接贡献到它的倍数，因为可以保证如果这个点的 $f$ 为 $x$，则其一定有 $f&#x3D;x-1$ 的某个因数，并且这个数一定会贡献到其能贡献到的地方</p>
<p>D萎了</p>
<p>20min-30min rush：</p>
<p>E(26min)：做很多次前缀和（？）</p>
<h3 id="ARC115D"><a href="#ARC115D" class="headerlink" title="ARC115D"></a>ARC115D</h3><p>对于欧拉回路有一个结论：</p>
<blockquote>
<p>  对于一个图 $G$，其DFS树上任意树环（只包含一个非树边的环）的异或图（所有边的存在性性异或起来）都是欧拉回路</p>
</blockquote>
<p>于是就能保证所有k个点度数都是奇数，所以式子是：<br>$$<br>\binom{n}{i}2^{m-n+1}<br>$$<br>对每个连通块跑一遍卷起来就行了</p>
<h3 id="ARC115E"><a href="#ARC115E" class="headerlink" title="ARC115E"></a>ARC115E</h3><p>应该可以线段树维护交错符号的前缀和，应该是 $O(n\log n)$ 的</p>
<p>但是有 $O(n)$ 的解法</p>
<p>考虑容斥，$g(t)$ 表示分成t段相等段的方案数，容斥系数为 $(-1)^{n-t}$​，所以可以直接dp $f(i)&#x3D;-\sum f(j)*\min{a_k}$</p>
<p>$\min{a_k}$ 可以单调栈维护</p>
<h3 id="ARC115F"><a href="#ARC115F" class="headerlink" title="ARC115F"></a>ARC115F</h3><p>暴力的思路：生成k元组表示k个点所在位置的状态，能够建出新图；即是在新图上跑瓶颈路</p>
<p>然后考虑二分，就变成了求可达性</p>
<p>发现二分的过程就是选取上界的过程</p>
<p>而对于一个新图上的路径，一定有一个最小值，我们就考虑从两边贪心地往这个最小值上靠</p>
<p>（鸽）</p>
<h2 id="9-2"><a href="#9-2" class="headerlink" title="9.2"></a>9.2</h2><p>deleted</p>
<h2 id="9-3"><a href="#9-3" class="headerlink" title="9.3"></a>9.3</h2><h3 id="vp记录-ARC123"><a href="#vp记录-ARC123" class="headerlink" title="[vp记录]ARC123"></a>[vp记录]ARC123</h3><p>咕咕咕</p>
<h3 id="省选联考2021-矩阵游戏"><a href="#省选联考2021-矩阵游戏" class="headerlink" title="[省选联考2021]矩阵游戏"></a>[省选联考2021]矩阵游戏</h3><p>首先可以明显构造出一个不合法解</p>
<p>然后考虑调整（*没有想到调整法，转而思考对边界元素的限制，差分约束-&gt;一般线性规划，得不偿失）</p>
<p>发现针对行&#x2F;列可以交错符号地调整，能保证b不变</p>
<p>于是对每一行&#x2F;列设置一个参数，对每个位置有一条边，变成了差分约束</p>
<p>注意每相邻行&#x2F;列符号交错，否则会有和式</p>
<h2 id="9-6"><a href="#9-6" class="headerlink" title="9.6"></a>9.6</h2><h3 id="HNOI2017-礼物"><a href="#HNOI2017-礼物" class="headerlink" title="[HNOI2017]礼物"></a>[HNOI2017]礼物</h3><p>推下式子发现常数的选择是固定的</p>
<p>于是就变成了最大化 $\sum x_iy_i$</p>
<p>把 $y$ 翻转就变成了卷积的形式，裸的FFT</p>
<h2 id="9-7"><a href="#9-7" class="headerlink" title="9.7"></a>9.7</h2><h3 id="HNOI2017-大佬"><a href="#HNOI2017-大佬" class="headerlink" title="[HNOI2017]大佬"></a>[HNOI2017]大佬</h3><p>关键点：能够发现直接BFS求出所有怼的可能复杂度是对的（*完全没有往这边想。。。有的时候确实应该多想想弔方法）</p>
<p>然后就求出了若干数对 $(d,f)$ ，其中d是使用的天数，f是打出的伤害</p>
<p>没有怼、1怼好求</p>
<p>2怼：$f_1+f_2\leq C\and f_1+f_2+(D-d_1-d_2)\geq C$</p>
<p>根据单调性枚举f1，然后求出满足条件的f2并使得f2-d2最大（前后缀最大值）</p>
<h3 id="HNOI2017-单旋"><a href="#HNOI2017-单旋" class="headerlink" title="[HNOI2017]单旋"></a>[HNOI2017]单旋</h3><p>找规律（*其实可以通过最值只有一个儿子来推，但是脑抽了推的是一般情况）</p>
<p>然后对每个点记录他的父亲和其中一个儿子，就能直接线段树维护</p>
<h3 id="HNOI2017-影魔"><a href="#HNOI2017-影魔" class="headerlink" title="[HNOI2017]影魔"></a>[HNOI2017]影魔</h3><p>考虑每个点，求出他能作为最大值贡献的区间 $[l_i,r_i]$</p>
<p>然后就是水水题了，可以离线+BIT做，也可以树套树</p>
<h2 id="9-8"><a href="#9-8" class="headerlink" title="9.8"></a>9.8</h2><h3 id="HAOI2017-供给侧改革"><a href="#HAOI2017-供给侧改革" class="headerlink" title="[HAOI2017]供给侧改革"></a>[HAOI2017]供给侧改革</h3><p>考虑后缀树（*因为有随机这个条件，所以可以优先考虑后缀树的树形结构（树高为 $O(\log n)$；而某sb只会后缀数组。。。）</p>
<p>然后考虑离线（干啥啥不行，离线第一名.jpg）按R升序排序</p>
<p>维护一个数组 $a_i$ 表示L&#x3D;i时的答案</p>
<p>那么对于每个加进来的数暴力跳祖先，对每个点维护它的endpos集合，然后在集合中找到R的前驱，更新 $a[1,i]$</p>
<p>不用担心R所在的子树被重复统计，因为这根本不会影响结果（弱智x）</p>
<p>upd：不需要维护endpos集合，这样会徒增一个log；因为可以直接在统计后把R加入所有的祖先中（捂脸）</p>
<h2 id="9-10"><a href="#9-10" class="headerlink" title="9.10"></a>9.10</h2><h3 id="NOIONLINE2021-岛屿探险"><a href="#NOIONLINE2021-岛屿探险" class="headerlink" title="[NOIONLINE2021]岛屿探险"></a>[NOIONLINE2021]岛屿探险</h3><p>首先，考虑子任务5,6,7</p>
<p>即求 $a_j\text{xor}c_i\leq d_i$，只有左边与j有关，于是考虑建其区间的01trie，可以分层做到 $O(\log n)$，然后多个操作整一个可持久化01trie即可</p>
<p>考虑子任务8,9,10,11</p>
<p>$a_j\text{xor}c_i\leq b_j,j\in[l_i,r_i]$，发现这个东西是和上一个东西对称的，于是可以把询问的l_i和r_i扔进2个01trie，然后把数当做询问做一个加权的上一个子任务</p>
<p>但是在100%的数据中，第一、二子任务都会出现，区分的条件是b和d的大小关系</p>
<p>于是就可以把数和询问都塞进一个数组做CDQ分治，然后讨论左对右的贡献，建01trie就能做到 $O((n+q)\log m\log(n+q))$</p>
<p>就对力</p>
<h2 id="9-12"><a href="#9-12" class="headerlink" title="9.12"></a>9.12</h2><h3 id="CF618G"><a href="#CF618G" class="headerlink" title="CF618G"></a>CF618G</h3><p>看不懂（悲</p>
<h2 id="9-13"><a href="#9-13" class="headerlink" title="9.13"></a>9.13</h2><h3 id="SDOI2019-染色"><a href="#SDOI2019-染色" class="headerlink" title="[SDOI2019]染色"></a>[SDOI2019]染色</h3><p>考虑一个只有空点的情况，可以轻易推出柿子</p>
<p>然后考虑分段，就变成了左右有限制的全空点</p>
<p>然后由于每段的左右都最多有 $O(m)$ 个状态</p>
<p>所以可以用奇技淫巧的线段树维护</p>
<p>但是看着难写</p>
<h3 id="CTSC2017-最长上升子序列"><a href="#CTSC2017-最长上升子序列" class="headerlink" title="[CTSC2017]最长上升子序列"></a>[CTSC2017]最长上升子序列</h3><p>首先可以Dilworth转化为求最小不降子序列覆盖</p>
<p>发现这个东西就是前缀的杨表的前k行数字的个数</p>
<p>但是这么做是$O(nr\log c)$ 的</p>
<p>考虑杨表是一个块，所以r和c至少有1个不会超过 $O(\sqrt{n})$ ，所以可以每次只枚举到 $\sqrt{n}$ 层就不累加了，然后枚举它的转置变成前k行就行了</p>
<h2 id="9-15"><a href="#9-15" class="headerlink" title="9.15"></a>9.15</h2><h3 id="JXOI2018-守卫"><a href="#JXOI2018-守卫" class="headerlink" title="[JXOI2018]守卫"></a>[JXOI2018]守卫</h3><p>被你妈骗了。。。</p>
<p>首先考虑DP，很简单，不用讲（*其实思考的时候有点小锅，要从第一个合法点开始转移才对）</p>
<p>然后怎么求第一个合法点就开始瞎想了</p>
<p>你妈，直接从后往前枚举左端点就好了（*你妈的凸壳）</p>
<h3 id="PKUSC2018-最大前缀和"><a href="#PKUSC2018-最大前缀和" class="headerlink" title="[PKUSC2018]最大前缀和"></a>[PKUSC2018]最大前缀和</h3><p>思考枚举前缀最大值的位置（最后）在哪里</p>
<p>然后有以下作为充要条件：</p>
<blockquote>
<p>  1.这个位置后面的前缀和全部小于0</p>
<p>  2.这个位置前面的后缀和（除去a1）全部大于等于0</p>
</blockquote>
<p>然后考虑两边分开求，然后合并；另一种意义下，这样的转化使得复杂的条件变成简单条件的组合，符合我们的本意</p>
<p>这提供了区别于转化枚举顺序的另一种优化思路：转化题目条件</p>
<p>这样就变成了三次状压DP力</p>
<h2 id="9-16"><a href="#9-16" class="headerlink" title="9.16"></a>9.16</h2><h3 id="PKUSC2018-星际穿越"><a href="#PKUSC2018-星际穿越" class="headerlink" title="[PKUSC2018]星际穿越"></a>[PKUSC2018]星际穿越</h3><p>首先对于每个点向前遍历节点代价是递增的</p>
<p>然后想到了数据结构维护当前点向前的函数，但是明显不好维护</p>
<p>然后可以发现向右走一步就是向右走的极限（想一想，为什么），所以可以直接定义一个位置的函数即为当前位置后缀的函数</p>
<p>发现这个函数可以由多个左端点描述，而确定了第一个左端点以后就可以划分为子问题</p>
<p>于是就可以倍增出每个点的2^i-th左端点</p>
<p>考虑询问：</p>
<p>然后把询问拆成 $[l_i,x_i)$ 和 $(r_i,x_i)$ 两部分</p>
<p>那么仔细理性地思考，发现这个东西可以直接倍增求（因为左端点在有节点跳跃的情况下也是连续的，逼近的过程仍然是 $\log n$ 的；区间的询问可以同时处理，每次对相应的长度实施+1即可）</p>
<p>最后注意一步到达的点要特殊处理</p>
<p>然后就做完了</p>
<p>（*对倍增没有感情，想到了倍增数组和拆分，然而不只是区间查询了，就连单点查询的可行性都不明晰，对于这样的问题，要先问问标准的倍增能不能做，不要复杂化）</p>
<h2 id="9-17"><a href="#9-17" class="headerlink" title="9.17"></a>9.17</h2><h3 id="THUSC2017-随机二分图"><a href="#THUSC2017-随机二分图" class="headerlink" title="[THUSC2017]随机二分图"></a>[THUSC2017]随机二分图</h3><p>第一步，转化枚举顺序！！！</p>
<p>先明晰题目给出的式子以图为维，计数 $\sum P(G)n(G)$</p>
<p>可以先枚举完美匹配（$O(n!)$），计数 $\sum P(permutation)$​ （把上式拆开重新组合，老套路）</p>
<p>（*直接莽，没有思考，直接奔着积和式去了，结果推出一堆屎；然而这一步以后就很通畅了，说明模型转化的能力十分重要，也是我需要克服的短板）</p>
<p>然后瓶颈在于枚举排列，考虑状压DP<br>$$<br>f_{S,T}&#x3D;[|S|&#x3D;|T|]\sum_{u\in T} f_{S-max(S),T-u}g_{S,T,&lt;max(S),u&gt;}<br>$$<br>（当然，可能需要取出两条边，这里为了方便不考虑）g表示当前点集内加入一条边对概率产生的贡献，很好求</p>
<p>这个东西是 $\sum_i \binom{n}{i}^2&#x3D;\binom{2n}{n}$，大约是1.5e8的数量级，然而明显卡不满</p>
<p>于是复杂度就是 $O(\binom{2n}{n}n)$ 的</p>
<h2 id="9-23"><a href="#9-23" class="headerlink" title="9.23"></a>9.23</h2><h3 id="郁金香"><a href="#郁金香" class="headerlink" title="郁金香"></a>郁金香</h3><p>很有意思的莫队题</p>
<p>首先由出现次数想到莫队</p>
<p>移动端点维护出现次数数组，并对每种出现次数维护出有多少种数字，这样就可以二分答案找到答案的出现次数</p>
<p>O(1)维护答案比较困难，考虑logn的做法：对每个答案开一个平衡树，维护最小值</p>
<p>这种做法的时间复杂度是$O(n\sqrt{n}\log n+n\log n)$，因为修改操作次数是 $O(n\sqrt{n})$ 的，而查询操作是 $O(n)$​</p>
<p>这启示我们寻找一个修改 $O(1)$，查询至多 $O(\sqrt{n })$ 的做法</p>
<p>明显可以数值分块，$f_{i,j}$ 表示出现次数为i，数值位于j块的数字个数</p>
<p>总的时间复杂度为 $O(n\sqrt{n})$</p>
<h3 id="CF1476G"><a href="#CF1476G" class="headerlink" title="CF1476G"></a>CF1476G</h3><p>牛逼莫队题</p>
<p>首先这是个裸的三维莫队，具体不讲，可见上一个题解</p>
<p>那么问题来了，统计出出现次数数组和其逆数组以后咋办</p>
<p>很不好维护</p>
<p>但是记得另一个根号结论：和为n的不同数数量为 $O(\sqrt{n})$</p>
<p>于是逆数组的点值总共只有根号渐进种选法</p>
<p>于是我们可以直接运算的数组的长度就变成 $O(\sqrt{n})$​ 的了，维护带不带log都无所谓，毕竟有个5&#x2F;3</p>
<p>$O(n^{\frac{5}{3}}+n^{\frac{3}{2}}\log n)$</p>
<h3 id="CF700D"><a href="#CF700D" class="headerlink" title="CF700D"></a>CF700D</h3><p>神仙莫队题，有价值</p>
<p>很明显是一个霍夫曼编码的问题，最大化 $\sum c_id_i$</p>
<p>这个问题可以通过脑补霍夫曼树并应用堆的方式做到一次查询 $O(n\log n)$ </p>
<p>但是不太行</p>
<p>我们考虑在 $c_i$ 维上分类讨论，设阈值为 $B$</p>
<p>对于大的数可以直接上堆，复杂度 $n&#x2F;B\log(n&#x2F;B)$</p>
<p>对于小的数可以转化为出现次数维上的问题，这个东西是可以模拟堆来合并的，需要注意的是当合并出来超出范围了，直接扔到上一种情况，对其复杂度不会有影响（因为总的数字的个数不超过n），这种情况的复杂度为 $O(b)$</p>
<p>总复杂度为 $O(q(B+n&#x2F;B\log(n&#x2F;B)))$，可以，均起来了，B取$\sqrt{n\log n}$ 就能做到 $O(q\sqrt{n\log n})$</p>
<h2 id="9-28"><a href="#9-28" class="headerlink" title="9.28"></a>9.28</h2><h3 id="ZJOI2017-仙人掌"><a href="#ZJOI2017-仙人掌" class="headerlink" title="[ZJOI2017]仙人掌"></a>[ZJOI2017]仙人掌</h3><p>（*被骗了，又想到矩阵去了，中途还乱想了一堆，最后得亏是迷途知返才想出来。。）</p>
<p>首先随便加一个边，发现这个边一定会在一个环里</p>
<p>所以加的边不能跨环，原图就变成森林了；且每个树边明显只能被一个新边覆盖，就变成了树上链覆盖问题了（*不用考虑链长是否要&gt;1，因为当链长&#x3D;1时这条边不选）</p>
<p>然后就直接DP就行了（要先DP出对于一个菊花心匹配其连边的方案数）</p>
<h2 id="9-29"><a href="#9-29" class="headerlink" title="9.29"></a>9.29</h2><h3 id="ZJOI2017-树状数组"><a href="#ZJOI2017-树状数组" class="headerlink" title="[ZJOI2017]树状数组"></a>[ZJOI2017]树状数组</h3><p>（*你妈，老傻逼了）</p>
<p>批斗：</p>
<p>首先每一段的概率之间明显不是独立的，故不能直接贡献，所以线段树做法驳回</p>
<p>其次这个东西是个后缀和，简直不能不看出来</p>
<p>最后他计算两个端点的贡献的时候必须要用树套树&#x2F;CDQ，结果并没有认清形势，放弃幻想</p>
<p>解：</p>
<p>首先转化为求两个点相等的概率</p>
<p>然后树套树<strong>直接</strong>维护(l,r)的概率，不要维护修改啥的（*）</p>
<p>CDQsb</p>
<h3 id="ZJOI2017-字符串"><a href="#ZJOI2017-字符串" class="headerlink" title="[ZJOI2017]字符串"></a>[ZJOI2017]字符串</h3><p>分块+hash+结论</p>
<p>不要一遇到后缀排序就sa啊kora</p>
<p>Significant Suffix最多只有 $\log n$ 个</p>
<p>然后用线段树维护每个 $[l,r]$ 的特征后缀集合</p>
<p>然后求LCP用字符串哈希</p>
<p>然而线段树维护哈希要4个log</p>
<p>所以哈希分块维护</p>
<h2 id="9-30"><a href="#9-30" class="headerlink" title="9.30"></a>9.30</h2><h3 id="CSP-S2020-贪吃蛇"><a href="#CSP-S2020-贪吃蛇" class="headerlink" title="[CSP-S2020]贪吃蛇"></a>[CSP-S2020]贪吃蛇</h3><p>再来看显然不难</p>
<p>首先思路比较好想，就是先假设这个蛇要吃，再判断是哪一步不能选择吃</p>
<p>需要注意的是如果某一步某一个蛇可能会被吃不能着急跳出，要看之后吃它的那一步会不会被选</p>
<p>然后维护显然不能用堆</p>
<p>发现每次max-min是单调不降的，所以开俩deque就行了</p>
<h2 id="2021-10"><a href="#2021-10" class="headerlink" title="2021.10"></a>2021.10</h2><h2 id="10-8"><a href="#10-8" class="headerlink" title="10.8"></a>10.8</h2><h3 id="ARC106E"><a href="#ARC106E" class="headerlink" title="ARC106E"></a>ARC106E</h3><p>有点意思</p>
<p>首先他明显能转化为一个二分答案</p>
<p>然后由于其复杂性难以运用简单算法</p>
<p>故转化为同样复杂的图论模型：</p>
<p>考虑一个 $NK+D$ 的二分图，NK是一个人的某个奖牌，D是天数</p>
<p>将每一天连向这一天能颁发的奖牌（每人K个都连），那么就是求一个左部为NK的二分图是否有完美匹配</p>
<p>那么就便乘了霍尔定理</p>
<p>对于一个集合，它的对应集只取决于这个集合中有的人</p>
<p>那么对于一个人的集合，就要满足<br>$$<br>|S|K\leq F(S)<br>$$<br>其中F(s)表示在D天内能覆盖的天数</p>
<p>这个东西可以 $O(N2^N)&#x2F;O(N2^N\log NK)$ 求</p>
<p>*没想到能这样转化（小本本……），二分图经验不够（摊手）</p>
<h3 id="ARC106F"><a href="#ARC106F" class="headerlink" title="ARC106F"></a>ARC106F</h3><p>什么神仙构造方法题。。</p>
<p>考虑一种构造：</p>
<p>对每一个点取一个被标记的洞</p>
<p>重复n-2次：</p>
<ol>
<li>选一个没被标记&amp;没选过的洞</li>
<li>再选一个被标记&amp;没选过&amp;和上一个洞不在同一个点的洞</li>
<li>连起来</li>
</ol>
<p>最后把剩下的俩标记的洞连起来</p>
<p>这种构造方法构造出来了一个会算重的方案，考虑去重：</p>
<p>考虑对一棵没有标记的树做标记</p>
<ol>
<li>选一条两端都被标记的边，从这条边向外延伸可以唯一确定一种标记方案</li>
<li>这条边永远是最后加入的，剩下的边加入顺序可以随便编排</li>
</ol>
<p>于是就变成了每种边的排列都有可能被算上，同时除以 $(n-1)!$ 就行<br>$$<br>\prod d_i \prod_{i&#x3D;1}^{n-3} (S-n-i)<br>$$<br>*一直在想生成函数和prufer序列，推出一大堆发现不会</p>
<p>*思维方面不够活跃，容易陷入套版</p>
<p><em>仔细想想，这个方案的构造和prufer序列有异曲同工之妙</em></p>
<p>但总之这种染色+除法原理的巧妙解法值得运用</p>
<h2 id="10-9"><a href="#10-9" class="headerlink" title="10.9"></a>10.9</h2><h3 id="Codeforces-Round-747-div-2"><a href="#Codeforces-Round-747-div-2" class="headerlink" title="Codeforces Round #747 (div.2)"></a>Codeforces Round #747 (div.2)</h3><p>太sb了</p>
<p>写一半没保存蓝屏。。</p>
<p>CDE1E2F都能一眼秒</p>
<p>AB反倒是想了半天，8min&#x2F;18min</p>
<p>一看榜一是3min&#x2F;2min，笑拉了</p>
<p>接下来是震撼人心的8次罚时400分，C2次D3次E1 3次，属实是牛批</p>
<p>C和D都算了，E1一个裸的式子能WA3次是赶着去投胎吗</p>
<p>然后是D，咋都不该写挂的</p>
<p>C写挂也是，哪能这么急啊</p>
<p>结果导致不禁被罚时，写的还慢，E1 90min才搞定</p>
<p>然后E2和F更精彩</p>
<p>看了E2会做直接跑去写了是吧</p>
<p>结果写不出来，属实难写</p>
<p>然后才去看F，发现是sb规律题，属于是出题人献祭亲妈了</p>
<p>也就剩60秒了，没蚌住</p>
<p>属于是喜提1000+了</p>
<h3 id="CF1575M"><a href="#CF1575M" class="headerlink" title="CF1575M"></a>CF1575M</h3><p>首先先一排一排的看</p>
<p>然后把式子拆一下：<br>$$<br>(x-x_i)^2+(y-y_i)^2&#x3D;x^2-2xx_i+x_i^2+(y-y_i)^2<br>$$<br>这是一个二次函数，多个二次函数求最值，直接斜率优化</p>
<h3 id="CF1575B"><a href="#CF1575B" class="headerlink" title="CF1575B"></a>CF1575B</h3><p>很简单</p>
<p>二分半径长度</p>
<p>然后脑补一个顺时针方向转动的圆，按所有点进入这个圆的先后把点排序</p>
<p>再按所有点出这个圆的先后把点排序</p>
<p>然后加点删点就能判断最大能有多少点了</p>
<h1 id="2021-11"><a href="#2021-11" class="headerlink" title="2021.11"></a>2021.11</h1><h2 id="11-16"><a href="#11-16" class="headerlink" title="11.16"></a>11.16</h2><h3 id="ZR20day18C"><a href="#ZR20day18C" class="headerlink" title="ZR20day18C"></a>ZR20day18C</h3><p>可以考虑对于一个点i有[l,r]，则[i,r]的所有点的右端点&lt;&#x3D;r</p>
<p>所以当只考虑右端点时，记忆化地暴力往左右两边跳（不论顺序）是O(n)次的</p>
<p>左端点同理</p>
<p>所以最终是O(nlogn)</p>
<h3 id="ZR10day10A"><a href="#ZR10day10A" class="headerlink" title="ZR10day10A"></a>ZR10day10A</h3><p>首先转化为差分的形式，就能变成两个点之间连边</p>
<p>然后就是要在一个图内选择边，使得每个点的度数和点权奇偶性相同</p>
<p>这是个模型，可以先考虑一个生成树，然后思考每种非树边的选择方法里，能用树边平衡的方法</p>
<p>很明显就是 $2^{非树边条数}$</p>
<h3 id="ZE10day10C"><a href="#ZE10day10C" class="headerlink" title="ZE10day10C"></a>ZE10day10C</h3><p>首先明显横竖是独立的，因为假设横着折一个位置，其合法性不会随纵着折了多少次而改变</p>
<p>然后hash一下就变成了对一个字符串判某个子串能否被折出来</p>
<p>一个很自然的想法就是分开考虑其左右端点</p>
<p>对于某一个缝，我们考虑让其作为左端点，首先要使得其回文半径接触左边界或内有另一个合法的点</p>
<p>然后考虑对于任意一对合法的左端点和右端点</p>
<p>把需要折的位置在串上标注出来，则从外往内整一定是对的（否则考虑abc|de往左折，显然最右边被折过的那个数既是a也是e，如果a&#x3D;e，则ab之间能再折一次）</p>
<p>所以只用manacher+统计就行了</p>
<h3 id="ZR20day18D"><a href="#ZR20day18D" class="headerlink" title="ZR20day18D"></a>ZR20day18D</h3><p>证明引理：</p>
<p>$\exist t,a_t&#x3D;max(a_i)\rightarrow b_t&#x3D;max(b_i),a_t-b_t\geq max(a_i-b_i)-1$​​​，其中a是直接把区间放上去的序列，b是被取消次数的序列</p>
<p>如果存在 $a_j\neq max(a_i)$​ 却满足之后的条件，说明 $a_j$​ 被取消的次数比 $a_t$​ 多，于是就可以把某个 $a_j$ 被取消，而 $a_t$ 没有的给补上（且可以证明所有满足条件的t一定在所有被取消的区间的交里）</p>
<p>所以只要找到了$a_t$​​​，就可以二分 $c&#x3D;max(a_i-b_i)$​​​ 求解</p>
<p>那么从左往右找，到每个位置要使得 $a_i-u+(a_t-c+1-u)\leq c$​​，$u$ 指截至目前用过的次数</p>
<p>贪心地，每次选择右端点最右的可行的区间，包含之前用剩的</p>
<p>费用提前计算并不精确。但是明显地，是正确的</p>
<h3 id="ZR20day16A"><a href="#ZR20day16A" class="headerlink" title="ZR20day16A"></a>ZR20day16A</h3><p>每次选择最小的一个团，加点就好了</p>
<h3 id="ZR20day16B"><a href="#ZR20day16B" class="headerlink" title="ZR20day16B"></a>ZR20day16B</h3><p> 根据LGV，答案为<br>$$<br>\begin{bmatrix}<br>\binom{a_1+1}{1}&amp;\binom{a_1+2}{2}&amp;\cdots&amp;\binom{a_1+n}{n}\<br>\binom{a_2+1}{1}&amp;\binom{a_2+2}{2}&amp;\cdots&amp;\binom{a_2+n}{n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>\binom{a_n+1}{1}&amp;\binom{a_n+2}{2}&amp;\cdots&amp;\binom{a_n+n}{n}\<br>\end{bmatrix}<br>$$<br>的行列式</p>
<p>每列提取出 $\frac{1}{j!}$</p>
<p>变成上升幂的形式</p>
<p>可以通过初等行变换变成普通幂的形式</p>
<p>也就是变成了范德蒙德行列式</p>
<p>直接带式子就行了：<br>$$<br>\prod_{i&#x3D;1}^n\frac{1}{i!}\prod_{i&#x3D;1}^na_i\prod_{1\leq i&lt;j\leq n}(a_j-a_i)<br>$$<br>后面的prod直接ntt</p>
<h2 id="11-17"><a href="#11-17" class="headerlink" title="11.17"></a>11.17</h2><h3 id="ZR20day15D"><a href="#ZR20day15D" class="headerlink" title="ZR20day15D"></a>ZR20day15D</h3><p>首先可以n^4DP</p>
<p>然后发现可以n^3</p>
<p>但是一般的n^3DP不太好优化</p>
<p>这需要发现另一种DP的方式，即枚举从 $x,y$，更新 $f_{x,i}\rightarrow f_{y,j}$</p>
<p>这样每次做是n的</p>
<p>然后考虑CDQ分治</p>
<p>具体的做法就是将[l,mid]和(mid,r]的中间线脑补成一行</p>
<p>就能把左边转移到它，再把它转移到右边所有</p>
<p>每一层是len^2的</p>
<p>分析下来n^2log</p>
<h3 id="ZR10day9D"><a href="#ZR10day9D" class="headerlink" title="ZR10day9D"></a>ZR10day9D</h3><p>对于 $\frac{x}{x+c_i}$，可以化简成 $\frac{1}{1+\frac{c_i}{x}}$</p>
<p>看到求一个 $Cx^{-1}$ 的式子，就应该有对泰勒展开的敏感​</p>
<p>当 $x&lt;c_i$ 时，</p>
<h1 id="2021-12"><a href="#2021-12" class="headerlink" title="2021.12"></a>2021.12</h1><h2 id="12-2"><a href="#12-2" class="headerlink" title="12.2"></a>12.2</h2><h3 id="LUOGU4027-货币兑换"><a href="#LUOGU4027-货币兑换" class="headerlink" title="LUOGU4027 货币兑换"></a>LUOGU4027 货币兑换</h3><p>是CDQ维护斜率优化的裸题</p>
<p>但是很久没有写斜率优化了，导致卡了许久</p>
<p>这里规范一下写法：</p>
<ul>
<li>使用斜率进行实数比较，比较时统一使用$&lt;$ 或 $&gt;$</li>
<li>求斜率时，特殊处理 $x_1&#x3D;x_2$ 的情况，若 $y_1&lt;y_2$ 输出 $+\infty$，否则输出 $-\infty$</li>
</ul>
<h3 id="LUOGU4585-火星商店问题"><a href="#LUOGU4585-火星商店问题" class="headerlink" title="LUOGU4585 火星商店问题"></a>LUOGU4585 火星商店问题</h3><p>首先应该能想到线段树分治，但是由于在时间维度上，修改为单点，询问为区间，所以不能直接做</p>
<p>于是把每个修改挂在时间线段树上的节点上，并考虑如何贡献</p>
<p>然后考虑在每个节点建立主席01trie，就能应对查询了，时间复杂度为 $O(n\log^2n)$</p>
<p>这里就体现出了线段树分治对有类似 $[l,r]$ 这样区间限制的贡献问题的优越性，若是使用高级数据结构就太难写，交给cdq处理就要多一个log</p>
<h2 id="12-5"><a href="#12-5" class="headerlink" title="12.5"></a>12.5</h2><h3 id="ARC131C"><a href="#ARC131C" class="headerlink" title="ARC131C"></a>ARC131C</h3><p>首先如果S在集合里面，那么就一定是先手胜</p>
<p>否则讨论集合大小是奇数还是偶数：</p>
<p>奇数：</p>
<p>首先，游戏明显不会在2步时结束，否则他就不会是奇数</p>
<p>然后，把这两步去掉，就变成了一个奇数的子问题，如此递归，一定是最后剩一个数，所以先手胜</p>
<p>偶数：</p>
<p>首先，游戏有可能在2步时结束</p>
<p>若结束了，则后手胜</p>
<p>若未结束，则递归进子问题</p>
<p>子问题的终点是后手拿光了所有的数，也是后手胜</p>
<h3 id="ARC131E"><a href="#ARC131E" class="headerlink" title="ARC131E"></a>ARC131E</h3><p>把它看成一个邻接矩阵，一个三元环就相当于一个直角三角形的三个顶点</p>
<p>那么考虑对一行一列来考虑，其集合的情况有以下两种：</p>
<ul>
<li>大小分别各不超过2，且两集合是包含关系</li>
<li>一个大小不超过3，另一个大小为1</li>
</ul>
<p>对于第一行来说，如果是第一种情况，那么所有的列最多也就何其相同，那么另一种颜色就一定访问不到，所以1这种情况排除；</p>
<p>如果是第二种情况，考虑所有行的大小都是1，那么很显然就没有列的限制了，就变得水水水水水</p>
<p>对每种颜色分配行，就做完力！芜湖</p>
<h2 id="12-20"><a href="#12-20" class="headerlink" title="12.20"></a>12.20</h2><h3 id="ABC232F"><a href="#ABC232F" class="headerlink" title="ABC232F"></a>ABC232F</h3><p>考虑先swap后增减，则可以构造一个排列 $P$ 使得答案为<br>$$<br>X\cdot\sum_{i&#x3D;1}^n|A_{P_i}-B_i|+Y\cdot \text{inv}(P)\<br>&#x3D;\sum_{i&#x3D;1}^nX\cdot |A_{P_i}-B_i|+Y\cdot#{x\in P_{[1,i)},x&gt;P_i}<br>$$<br>右边的井号部分只和已选元素的集合有关，所以可以状压DP，时间复杂度为 $O(n^22^n)$​。</p>
<h3 id="ABC232G"><a href="#ABC232G" class="headerlink" title="ABC232G"></a>ABC232G</h3><p>可以使用dijkstra算法，但是由于边数为 $O(n^2)$，故不满足时间限制。</p>
<p>由于 $(A+B)<del>\text{mod}</del>M&#x3D;(B-(-A))<del>\text{mod}</del>M$​，而两数之差在模意义下为两数顺时针移动的步数，因此可以离散化以后建出值域点，值域点之间按从小到大连边（同时最大点连向最小点），即可简化图内信息。</p>
<h2 id="12-22"><a href="#12-22" class="headerlink" title="12.22"></a>12.22</h2><h3 id="CF1100F"><a href="#CF1100F" class="headerlink" title="CF1100F"></a>CF1100F</h3><p>有两种做法</p>
<h4 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol.1"></a>Sol.1</h4><p>固定右端点，那么随着左端点向左扩展，线性基最多只会变化 $\lfloor\log V\rfloor$ 次，所以每次把 $a[r]$ 插入这些线性基中，总时间复杂度为 $O(n\log^2 V)$（记录下来，可以在线！）。</p>
<h4 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol.2"></a>Sol.2</h4><p>如果可以在右端点向右推进时维护一个全局的线性基，使得当前的询问均可在其中查询就好了。</p>
<p>思考线性基求 $\max$ 的实质：从高到低位遍历，如果当前答案的该位为0且线性基的该位有值，则将答案异或该值。</p>
<p>考虑在线性基中对每个值维护一个下标 $pos_i$。如果 $l\leq pos_i$​，则可以扔进去。</p>
<p>这样做的要求是 $pos_i$​ 尽可能大。由于每个数只能在线性基中插入一位，而每次都要贪心地选择最高位插入，所以线性基插入时需要 swap 当前值和记录值，以保证这一位的 $pos_i$​​ 最大。</p>
<p>总时间复杂度为 $O(n\log V)$（记录下来，可以在线）。</p>
<h1 id="2022-1"><a href="#2022-1" class="headerlink" title="2022.1"></a>2022.1</h1><h2 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h2><h3 id="P2303-SDOI2012-Longge-的问题"><a href="#P2303-SDOI2012-Longge-的问题" class="headerlink" title="P2303 [SDOI2012] Longge 的问题"></a>P2303 [SDOI2012] Longge 的问题</h3><p>式子：<br>$$<br>\sum_{i&#x3D;1}^{n}\gcd(i,n)&#x3D;\sum_{d|d}\sum_{i&#x3D;1}^{n} d[d&#x3D;gcd(i,n)]\<br>&#x3D;\sum_{d|n}d\sum_{i&#x3D;1}^{\frac{n}{d}}[gcd(i,\frac{n}{d})&#x3D;1]\<br>&#x3D;\sum_{d|n}d\sum_{i&#x3D;1}^{\frac{n}{d}}\sum_{j|i\and j|\frac{n}{d}}\mu(j)\<br>&#x3D;\sum_{d|n}d\sum_{j|\frac{n}{d}}\mu(j)\frac{n}{dj}\<br>&#x3D;n\sum_{d|n}\sum_{j|\frac{n}{d}}\frac{\mu(j)}{j}\<br>&#x3D;\sum_{j|n}(n&#x2F;j)d(n&#x2F;j)\mu(j)<br>$$<br>理论上没有什么问题，但是可以用欧拉函数：<br>$$<br>\sum_{i&#x3D;1}^{n}\gcd(i,n)&#x3D;\sum_{d|d}\sum_{i&#x3D;1}^{n} d[d&#x3D;gcd(i,n)]\<br>&#x3D;\sum_{d|n}d\sum_{i&#x3D;1}^{\frac{n}{d}}[gcd(i,\frac{n}{d})&#x3D;1]\<br>&#x3D;\sum_{d|n}d\phi(d)<br>$$<br>基础不扎实（摊手）</p>
<h3 id="CF1334E-Divisor-Paths"><a href="#CF1334E-Divisor-Paths" class="headerlink" title="CF1334E Divisor Paths"></a>CF1334E Divisor Paths</h3><p>基础不扎实（摊手）</p>
<p>首先考虑成倍数的情况，那么一定是直直的走过去，所以答案为算gcd的素因子的可重集</p>
<p>那么如果是任意数的话，一定是先向下走，再向上走</p>
<p>那么就算x-&gt;gcd-&gt;y就好了</p>
<h3 id="P3868-TJOI2009-猜数字"><a href="#P3868-TJOI2009-猜数字" class="headerlink" title="P3868 [TJOI2009] 猜数字"></a>P3868 [TJOI2009] 猜数字</h3><p>差点都忘了CRT怎么写了</p>
<p>首先就是类似于拉格朗日插值，构造值 $v_i$ 使得除了膜 $b_i$ 为 $a_i$，其他都是0</p>
<p>然后加起来就行</p>
<p>excrt再说吧</p>
<h3 id="P3312-SDOI2014-数表"><a href="#P3312-SDOI2014-数表" class="headerlink" title="P3312 [SDOI2014]数表"></a>P3312 [SDOI2014]数表</h3><p>$$<br>a_{i,j}&#x3D;\sum_{d|gcd(i,j)}d\<br>\<br>\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^mv_{gcd(i,j)}\sum_{d|gcd(i,j)}d\<br>…\<br>&#x3D;\sum_{x&#x3D;1}^n\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{x}\rfloor\sum_{d|x}\sigma_1(d)\mu(\frac{x}{d})<br>$$</p>
<p>正常来说，可以很简单地求，但是sigma_1会变</p>
<p>涉及到修改和询问，需要结合数据结构，设后面的sum为 $s(x)$，则只要维护好 $s(x)$，就能轻松求值</p>
<p>如果按正常顺序做，修改操作的数量过多，所以考虑预处理或离线，这里用离线做（离线显然好写）</p>
<p>那么按sigma_1排序就会发现每次操作即使为 $s(x)$ 新增一项，而 $s(x)$ 的个数是调和log的</p>
<p>所以这么做就好做了，时间复杂度为 $O(n\log^2n+q\sqrt n)$</p>
<h2 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h2><h3 id="P3327-SDOI2015-约数个数和"><a href="#P3327-SDOI2015-约数个数和" class="headerlink" title="P3327 [SDOI2015]约数个数和"></a>P3327 [SDOI2015]约数个数和</h3><p>$$<br>\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^m\sum_{x|i}\sum_{y|j}[gcd(x,y)&#x3D;1]\<br>\sum_{x&#x3D;1}^n\sum_{y&#x3D;1}^m\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor\sum_{d|\gcd(x,y)}\mu(d)\<br>\sum_{d&#x3D;1}^m\mu(d)\sum_{x&#x3D;1}^{\lfloor\frac{n}{d}\rfloor}\lfloor\frac{n}{dx}\rfloor\sum_{y&#x3D;1}^{\lfloor\frac{m}{d}\rfloor}\lfloor\frac{m}{dy}\rfloor<br>$$</p>
<p>难点在第一步。因为转换枚举顺序发现无法维护，于是考虑替换 $d(ij)$。朴素的想法是枚举 $x,y$ 分别整除 $i,j$，但是会算重，于是规定只有 $gcd(i,j&#x2F;y)&#x3D;1$ 时才贡献，就有了最开始的式子。</p>
<p>在第二步时总是会多余地引进 $g$ 来表示gcd，但是这是多余的。</p>
<h3 id="P5330-SNOI2019-数论"><a href="#P5330-SNOI2019-数论" class="headerlink" title="P5330 [SNOI2019]数论"></a>P5330 [SNOI2019]数论</h3><p>$$<br>x\equiv a\pmod p\<br>x\equiv b\pmod q\<br>k_1p+a&#x3D;k_2q+b\<br>k_1p-k_2q&#x3D;b-a\<br>\Rightarrow k’_1p-k’_2q&#x3D;\gcd(p,q)\<br>$$</p>
<p>但是没啥用，因为对于末尾难以分析。</p>
<p>可以换种思路，考虑对 $a_i$ 求可行的 $x,px+a_i\equiv b_j\pmod q$。</p>
<p>在固定 $a_i$ 时，不断 $i++$ 会形成一个环。</p>
<p>对每个 $a_i$，在这个环跳，对每个点做记录就好了。</p>
<p>（所以最后为啥变成了图论题）</p>
<p>写完一块代码，记得检查该清空的是否清空哦~</p>
<h2 id="1-6"><a href="#1-6" class="headerlink" title="1.6"></a>1.6</h2><h3 id="P5323-BJOI2019-光线"><a href="#P5323-BJOI2019-光线" class="headerlink" title="P5323 [BJOI2019]光线"></a>P5323 [BJOI2019]光线</h3><p>设 $f_i,g_i$ 分别表示从这块玻璃向后射的光线量，向前射的光线量</p>
<p>那么可以列出式子：<br>$$<br>\begin{cases}<br>a_{i}f_{i}+b_ig_{i}&#x3D;f_{i+1}\<br>b_if_{i}+a_ig_{i}&#x3D;g_{i-1}<br>\end{cases}<br>$$<br>当 $i&#x3D;n$ 时，有<br>$$<br>\begin{cases}<br>a_nf_n&#x3D;f_{n+1}\<br>b_nf_n&#x3D;g_{n-1}<br>\end{cases}<br>$$<br>答案是 $f_{n+1}$。根据上两式，所有的 $f_i,g_i$ 都能用 $f_{n+1}$，反带到 $f_1&#x3D;1$ 即可</p>
<h2 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h2><h3 id="P4589-TJOI2018-智力竞赛"><a href="#P4589-TJOI2018-智力竞赛" class="headerlink" title="P4589 [TJOI2018]智力竞赛"></a>P4589 [TJOI2018]智力竞赛</h3><p>使用二分答案让问题变成选择固定的某些点。</p>
<p>这个问题可以费用流。</p>
<p>但是显然不用这么麻烦，因为转化一下问题就变成了寻找图上的链覆盖，然后裸着做就好了。</p>
<p>虽然板子是说DAG，但是有环图上不经过重复点的链覆盖也能做。</p>
<h2 id="1-10"><a href="#1-10" class="headerlink" title="1.10"></a>1.10</h2><h3 id="CF888G-Xor-MST"><a href="#CF888G-Xor-MST" class="headerlink" title="CF888G Xor-MST"></a>CF888G Xor-MST</h3><p>首先就能想到B算法。</p>
<p>但是直接运用比较麻烦，考虑简化。</p>
<p>注意到查询连通块之间的答案时，可以运用字典树，如果能启发式合并的话时间复杂度可以接受，于是继续寻找性质，使得字典树和B算法可以很好的结合。</p>
<p>从高位到低位处理时，可以发现合并相邻两个子树是最优的。</p>
<p>于是就这么做了，还不用可持久化。</p>
<h2 id="1-11"><a href="#1-11" class="headerlink" title="1.11"></a>1.11</h2><p>deleted</p>
<h2 id="1-12"><a href="#1-12" class="headerlink" title="1.12"></a>1.12</h2><p>deleted</p>
<h3 id="CF1625D"><a href="#CF1625D" class="headerlink" title="CF1625D"></a>CF1625D</h3><p>建出全局trie树，发现如果某个子树的深度&gt;某个值D的话，两个子树的集合就能简单合并，&lt;D的话，就无法合并，&#x3D;D的话，就可以把左子树的值在右子树中查询，判断这个子树是选一个数还是两个数。</p>
<p>思路比较简单，但是不好写。</p>
<h2 id="1-13"><a href="#1-13" class="headerlink" title="1.13"></a>1.13</h2><h3 id="CF1625E"><a href="#CF1625E" class="headerlink" title="CF1625E"></a>CF1625E</h3><p>对于一个合法的括号序列，可以建出一棵树来表示其结构（树上的每个点表示一个括号对）。</p>
<p>每一个询问在一棵树上的表示一定是同一层上的连续节点。</p>
<p>每一个修改在一棵树上的表示即为删除一个叶子结点，并将祖先都减去同一个数。</p>
<p>所以可以 $O(n\sqrt{n\log n})$ 操作分块。</p>
<p>（未完待续）</p>
<p>由于节点DFS序与BFS序无关且混乱，所以考虑查询的时候查询子树。</p>
<p>因为每次更新都是在根到某点的链上减去同一个常数，所以将权值与深度结合可解。</p>
<h2 id="1-14"><a href="#1-14" class="headerlink" title="1.14"></a>1.14</h2><p>deleted</p>
<h3 id="P4768-NOI2018-归程"><a href="#P4768-NOI2018-归程" class="headerlink" title="P4768 [NOI2018] 归程"></a>P4768 [NOI2018] 归程</h3><p>先跑个单源最短路，再建出kruskal重构树，直接做出来了。</p>
<h3 id="P5633-最小度限制生成tree"><a href="#P5633-最小度限制生成tree" class="headerlink" title="P5633 最小度限制生成tree"></a>P5633 最小度限制生成tree</h3><p>很显然的一个wqs二分的限制，直接做wqs二分，与s相连的边都+&#x3D;c。</p>
<h3 id="P1484-种树"><a href="#P1484-种树" class="headerlink" title="P1484 种树"></a>P1484 种树</h3><p>固然可以反悔贪心，但也能花哨地wqs二分。</p>
<p>正常地wqs二分就好了，斜率一定是为整数。</p>
<p>由于求的是&lt;&#x3D;k的最大值，所以可以把斜率下界设为1。</p>
<h2 id="1-15"><a href="#1-15" class="headerlink" title="1.15"></a>1.15</h2><p>deleted</p>
<h2 id="1-16"><a href="#1-16" class="headerlink" title="1.16"></a>1.16</h2><p>deleted</p>
<h3 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h3><p>最近总感觉没什么动力，且正逢我练习打字的时段，于是打算把所谓好题集给刷穿。</p>
<p>（校注：孩子你想多了）</p>
<h3 id="P4747-CERC2017-Intrinsic-Interval"><a href="#P4747-CERC2017-Intrinsic-Interval" class="headerlink" title="P4747 [CERC2017]Intrinsic Interval"></a>P4747 [CERC2017]Intrinsic Interval</h3><p>根据这样的区间满足 $mx-mn&#x3D;r-l$，即 $mx-mn-l&#x3D;r$ 的结论，因此在固定右端点的情况下，可以知道每个左端点的答案。</p>
<p>这里用线段树维护。</p>
<p>然后从左到右扫，遇到右端点把左端点加入大根堆，每次把可行的拎出来就好。这样一定是对的因为如果存在 $[l_1,r_1],[l_2,r_2],l_1&lt;l_2,r_1&lt;r_2$ 都满足要求，则 $[l_2,r_1]$ 也一定满足。</p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/2024/03/01/hesse/"
      title="黑塞两本书读后感"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        黑塞两本书读后感
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2023/12/10/hello-world/"
      title="Hello World"
     >

    <p class="title-text">
      
        Hello World
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>

 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner" align="center">
    
    &copy; 2024 S // W // L<br>
    Powered by<br> <a href="https://hexo.io/" target="_blank">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <i class="fa-solid fa-angle-up"></i>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
